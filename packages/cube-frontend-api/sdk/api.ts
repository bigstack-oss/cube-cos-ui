/* tslint:disable */
/* eslint-disable */
/**
 * Cube COS API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CreateEmailRecipient500Response
 */
export interface CreateEmailRecipient500Response {
    /**
     * 
     * @type {number}
     * @memberof CreateEmailRecipient500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateEmailRecipient500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEmailRecipient500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface CreateSlackChannel500Response
 */
export interface CreateSlackChannel500Response {
    /**
     * 
     * @type {number}
     * @memberof CreateSlackChannel500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateSlackChannel500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateSlackChannel500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DeleteEmailRecipient500Response
 */
export interface DeleteEmailRecipient500Response {
    /**
     * 
     * @type {number}
     * @memberof DeleteEmailRecipient500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeleteEmailRecipient500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeleteEmailRecipient500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DeleteEmailRecipientResponse
 */
export interface DeleteEmailRecipientResponse {
    /**
     * 
     * @type {number}
     * @memberof DeleteEmailRecipientResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteEmailRecipientResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteEmailRecipientResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface DeleteEmailSenderResponse
 */
export interface DeleteEmailSenderResponse {
    /**
     * 
     * @type {number}
     * @memberof DeleteEmailSenderResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteEmailSenderResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteEmailSenderResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface DeleteSlackChannel500Response
 */
export interface DeleteSlackChannel500Response {
    /**
     * 
     * @type {number}
     * @memberof DeleteSlackChannel500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeleteSlackChannel500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeleteSlackChannel500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DeleteSlackChannelResponse
 */
export interface DeleteSlackChannelResponse {
    /**
     * 
     * @type {number}
     * @memberof DeleteSlackChannelResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteSlackChannelResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof DeleteSlackChannelResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface DiskReadWriteHistory
 */
export interface DiskReadWriteHistory {
    /**
     * 
     * @type {string}
     * @memberof DiskReadWriteHistory
     */
    'unit': string;
    /**
     * 
     * @type {Array<MetricRankRankInnerHistoryInner>}
     * @memberof DiskReadWriteHistory
     */
    'read': Array<MetricRankRankInnerHistoryInner>;
    /**
     * 
     * @type {Array<MetricRankRankInnerHistoryInner>}
     * @memberof DiskReadWriteHistory
     */
    'write': Array<MetricRankRankInnerHistoryInner>;
}
/**
 * 
 * @export
 * @interface EmailRecipient
 */
export interface EmailRecipient {
    /**
     * 
     * @type {string}
     * @memberof EmailRecipient
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof EmailRecipient
     */
    'note': string;
    /**
     * 
     * @type {boolean}
     * @memberof EmailRecipient
     */
    'isTestable': boolean;
}
/**
 * 
 * @export
 * @interface EmailSender
 */
export interface EmailSender {
    /**
     * 
     * @type {string}
     * @memberof EmailSender
     */
    'host': string;
    /**
     * 
     * @type {number}
     * @memberof EmailSender
     */
    'port': number;
    /**
     * 
     * @type {string}
     * @memberof EmailSender
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof EmailSender
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof EmailSender
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof EmailSender
     */
    'accessVerified': boolean;
}
/**
 * 
 * @export
 * @interface GetAbstractedEventsResponse
 */
export interface GetAbstractedEventsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetAbstractedEventsResponse
     */
    'code': number;
    /**
     * 
     * @type {GetAbstractedEventsResponseData}
     * @memberof GetAbstractedEventsResponse
     */
    'data': GetAbstractedEventsResponseData;
    /**
     * 
     * @type {string}
     * @memberof GetAbstractedEventsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetAbstractedEventsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetAbstractedEventsResponseData
 */
export interface GetAbstractedEventsResponseData {
    /**
     * 
     * @type {Array<GetAbstractedEventsResponseDataEventsInner>}
     * @memberof GetAbstractedEventsResponseData
     */
    'events': Array<GetAbstractedEventsResponseDataEventsInner>;
    /**
     * 
     * @type {GetAbstractedEventsResponseDataLimit}
     * @memberof GetAbstractedEventsResponseData
     */
    'limit': GetAbstractedEventsResponseDataLimit;
}
/**
 * 
 * @export
 * @interface GetAbstractedEventsResponseDataEventsInner
 */
export interface GetAbstractedEventsResponseDataEventsInner {
    /**
     * 
     * @type {string}
     * @memberof GetAbstractedEventsResponseDataEventsInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GetAbstractedEventsResponseDataEventsInner
     */
    'severity': string;
    /**
     * 
     * @type {string}
     * @memberof GetAbstractedEventsResponseDataEventsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetAbstractedEventsResponseDataEventsInner
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GetAbstractedEventsResponseDataEventsInner
     */
    'host': string;
    /**
     * 
     * @type {string}
     * @memberof GetAbstractedEventsResponseDataEventsInner
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof GetAbstractedEventsResponseDataEventsInner
     */
    'service': string;
    /**
     * 
     * @type {GetAbstractedEventsResponseDataEventsInnerMetadata}
     * @memberof GetAbstractedEventsResponseDataEventsInner
     */
    'metadata': GetAbstractedEventsResponseDataEventsInnerMetadata;
    /**
     * 
     * @type {string}
     * @memberof GetAbstractedEventsResponseDataEventsInner
     */
    'time': string;
}
/**
 * 
 * @export
 * @interface GetAbstractedEventsResponseDataEventsInnerMetadata
 */
export interface GetAbstractedEventsResponseDataEventsInnerMetadata {
    /**
     * 
     * @type {string}
     * @memberof GetAbstractedEventsResponseDataEventsInnerMetadata
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAbstractedEventsResponseDataEventsInnerMetadata
     */
    'ip'?: string;
}
/**
 * 
 * @export
 * @interface GetAbstractedEventsResponseDataLimit
 */
export interface GetAbstractedEventsResponseDataLimit {
    /**
     * 
     * @type {number}
     * @memberof GetAbstractedEventsResponseDataLimit
     */
    'number': number;
    /**
     * 
     * @type {string}
     * @memberof GetAbstractedEventsResponseDataLimit
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface GetCpuUsageRankOfHostsResponse
 */
export interface GetCpuUsageRankOfHostsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetCpuUsageRankOfHostsResponse
     */
    'code': number;
    /**
     * 
     * @type {MetricRank}
     * @memberof GetCpuUsageRankOfHostsResponse
     */
    'data': MetricRank;
    /**
     * 
     * @type {string}
     * @memberof GetCpuUsageRankOfHostsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetCpuUsageRankOfHostsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetCpuUsageRankOfVmsResponse
 */
export interface GetCpuUsageRankOfVmsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetCpuUsageRankOfVmsResponse
     */
    'code': number;
    /**
     * 
     * @type {MetricRank}
     * @memberof GetCpuUsageRankOfVmsResponse
     */
    'data': MetricRank;
    /**
     * 
     * @type {string}
     * @memberof GetCpuUsageRankOfVmsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetCpuUsageRankOfVmsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetCpuUsageSummaryOfHostsResponse
 */
export interface GetCpuUsageSummaryOfHostsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetCpuUsageSummaryOfHostsResponse
     */
    'code': number;
    /**
     * 
     * @type {GetMetricsResponseDataHostUsagesInnerCpu}
     * @memberof GetCpuUsageSummaryOfHostsResponse
     */
    'data': GetMetricsResponseDataHostUsagesInnerCpu;
    /**
     * 
     * @type {string}
     * @memberof GetCpuUsageSummaryOfHostsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetCpuUsageSummaryOfHostsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetDataCenter500Response
 */
export interface GetDataCenter500Response {
    /**
     * 
     * @type {number}
     * @memberof GetDataCenter500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetDataCenter500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDataCenter500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetDataCenterResponse
 */
export interface GetDataCenterResponse {
    /**
     * 
     * @type {number}
     * @memberof GetDataCenterResponse
     */
    'code': number;
    /**
     * 
     * @type {GetDataCentersResponseDataInner}
     * @memberof GetDataCenterResponse
     */
    'data': GetDataCentersResponseDataInner;
    /**
     * 
     * @type {string}
     * @memberof GetDataCenterResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetDataCenterResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetDataCenters500Response
 */
export interface GetDataCenters500Response {
    /**
     * 
     * @type {number}
     * @memberof GetDataCenters500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetDataCenters500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDataCenters500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetDataCentersResponse
 */
export interface GetDataCentersResponse {
    /**
     * 
     * @type {number}
     * @memberof GetDataCentersResponse
     */
    'code': number;
    /**
     * 
     * @type {Array<GetDataCentersResponseDataInner>}
     * @memberof GetDataCentersResponse
     */
    'data': Array<GetDataCentersResponseDataInner>;
    /**
     * 
     * @type {string}
     * @memberof GetDataCentersResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetDataCentersResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetDataCentersResponseDataInner
 */
export interface GetDataCentersResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetDataCentersResponseDataInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetDataCentersResponseDataInner
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof GetDataCentersResponseDataInner
     */
    'virtualIp': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetDataCentersResponseDataInner
     */
    'isHaEnabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetDataCentersResponseDataInner
     */
    'isLocal': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetDataCentersResponseDataInner
     */
    'utcTimeZone': string;
    /**
     * 
     * @type {GetDataCentersResponseDataInnerAdditional}
     * @memberof GetDataCentersResponseDataInner
     */
    'additional': GetDataCentersResponseDataInnerAdditional;
}
/**
 * 
 * @export
 * @interface GetDataCentersResponseDataInnerAdditional
 */
export interface GetDataCentersResponseDataInnerAdditional {
    /**
     * 
     * @type {string}
     * @memberof GetDataCentersResponseDataInnerAdditional
     */
    'helpUrl': string;
}
/**
 * 
 * @export
 * @interface GetDiskBandwidthHistoryOfHostsResponse
 */
export interface GetDiskBandwidthHistoryOfHostsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetDiskBandwidthHistoryOfHostsResponse
     */
    'code': number;
    /**
     * 
     * @type {DiskReadWriteHistory}
     * @memberof GetDiskBandwidthHistoryOfHostsResponse
     */
    'data': DiskReadWriteHistory;
    /**
     * 
     * @type {string}
     * @memberof GetDiskBandwidthHistoryOfHostsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetDiskBandwidthHistoryOfHostsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetDiskIopsHistoryOfHostsResponse
 */
export interface GetDiskIopsHistoryOfHostsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetDiskIopsHistoryOfHostsResponse
     */
    'code': number;
    /**
     * 
     * @type {DiskReadWriteHistory}
     * @memberof GetDiskIopsHistoryOfHostsResponse
     */
    'data': DiskReadWriteHistory;
    /**
     * 
     * @type {string}
     * @memberof GetDiskIopsHistoryOfHostsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetDiskIopsHistoryOfHostsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetDiskLatencyHistoryOfHostsResponse
 */
export interface GetDiskLatencyHistoryOfHostsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetDiskLatencyHistoryOfHostsResponse
     */
    'code': number;
    /**
     * 
     * @type {DiskReadWriteHistory}
     * @memberof GetDiskLatencyHistoryOfHostsResponse
     */
    'data': DiskReadWriteHistory;
    /**
     * 
     * @type {string}
     * @memberof GetDiskLatencyHistoryOfHostsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetDiskLatencyHistoryOfHostsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetDiskReadIopsRankOfVmsResponse
 */
export interface GetDiskReadIopsRankOfVmsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetDiskReadIopsRankOfVmsResponse
     */
    'code': number;
    /**
     * 
     * @type {MetricRank}
     * @memberof GetDiskReadIopsRankOfVmsResponse
     */
    'data': MetricRank;
    /**
     * 
     * @type {string}
     * @memberof GetDiskReadIopsRankOfVmsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetDiskReadIopsRankOfVmsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetDiskUsageRankOfHostsResponse
 */
export interface GetDiskUsageRankOfHostsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetDiskUsageRankOfHostsResponse
     */
    'code': number;
    /**
     * 
     * @type {MetricRank}
     * @memberof GetDiskUsageRankOfHostsResponse
     */
    'data': MetricRank;
    /**
     * 
     * @type {string}
     * @memberof GetDiskUsageRankOfHostsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetDiskUsageRankOfHostsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetDiskWriteIopsRankOfVmsResponse
 */
export interface GetDiskWriteIopsRankOfVmsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetDiskWriteIopsRankOfVmsResponse
     */
    'code': number;
    /**
     * 
     * @type {MetricRank}
     * @memberof GetDiskWriteIopsRankOfVmsResponse
     */
    'data': MetricRank;
    /**
     * 
     * @type {string}
     * @memberof GetDiskWriteIopsRankOfVmsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetDiskWriteIopsRankOfVmsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetEmailRecipients500Response
 */
export interface GetEmailRecipients500Response {
    /**
     * 
     * @type {number}
     * @memberof GetEmailRecipients500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetEmailRecipients500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetEmailRecipients500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetEmailRecipientsResponse
 */
export interface GetEmailRecipientsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetEmailRecipientsResponse
     */
    'code': number;
    /**
     * 
     * @type {Array<EmailRecipient>}
     * @memberof GetEmailRecipientsResponse
     */
    'data': Array<EmailRecipient>;
    /**
     * 
     * @type {string}
     * @memberof GetEmailRecipientsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetEmailRecipientsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetEmailSenders500Response
 */
export interface GetEmailSenders500Response {
    /**
     * 
     * @type {number}
     * @memberof GetEmailSenders500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetEmailSenders500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetEmailSenders500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetEmailSendersResponse
 */
export interface GetEmailSendersResponse {
    /**
     * 
     * @type {number}
     * @memberof GetEmailSendersResponse
     */
    'code': number;
    /**
     * 
     * @type {GetEmailSendersResponseData}
     * @memberof GetEmailSendersResponse
     */
    'data': GetEmailSendersResponseData;
    /**
     * 
     * @type {string}
     * @memberof GetEmailSendersResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetEmailSendersResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetEmailSendersResponseData
 */
export interface GetEmailSendersResponseData {
    /**
     * 
     * @type {Array<EmailSender>}
     * @memberof GetEmailSendersResponseData
     */
    'emailSenders'?: Array<EmailSender>;
}
/**
 * 
 * @export
 * @interface GetEventFilterConditionResponse
 */
export interface GetEventFilterConditionResponse {
    /**
     * 
     * @type {number}
     * @memberof GetEventFilterConditionResponse
     */
    'code': number;
    /**
     * 
     * @type {GetEventFilterConditionResponseData}
     * @memberof GetEventFilterConditionResponse
     */
    'data': GetEventFilterConditionResponseData;
    /**
     * 
     * @type {string}
     * @memberof GetEventFilterConditionResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetEventFilterConditionResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetEventFilterConditionResponseData
 */
export interface GetEventFilterConditionResponseData {
    /**
     * 
     * @type {GetEventFilterConditionResponseDataSystem}
     * @memberof GetEventFilterConditionResponseData
     */
    'system': GetEventFilterConditionResponseDataSystem;
    /**
     * 
     * @type {GetEventFilterConditionResponseDataInstance}
     * @memberof GetEventFilterConditionResponseData
     */
    'instance': GetEventFilterConditionResponseDataInstance;
    /**
     * 
     * @type {GetEventFilterConditionResponseDataHost}
     * @memberof GetEventFilterConditionResponseData
     */
    'host': GetEventFilterConditionResponseDataHost;
}
/**
 * 
 * @export
 * @interface GetEventFilterConditionResponseDataHost
 */
export interface GetEventFilterConditionResponseDataHost {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetEventFilterConditionResponseDataHost
     */
    'names': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetEventFilterConditionResponseDataHost
     */
    'categories': Array<string>;
}
/**
 * 
 * @export
 * @interface GetEventFilterConditionResponseDataInstance
 */
export interface GetEventFilterConditionResponseDataInstance {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetEventFilterConditionResponseDataInstance
     */
    'ids': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetEventFilterConditionResponseDataInstance
     */
    'categories': Array<string>;
}
/**
 * 
 * @export
 * @interface GetEventFilterConditionResponseDataSystem
 */
export interface GetEventFilterConditionResponseDataSystem {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetEventFilterConditionResponseDataSystem
     */
    'severities': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetEventFilterConditionResponseDataSystem
     */
    'categories': Array<string>;
}
/**
 * 
 * @export
 * @interface GetEventFilterConditions500Response
 */
export interface GetEventFilterConditions500Response {
    /**
     * 
     * @type {number}
     * @memberof GetEventFilterConditions500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetEventFilterConditions500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetEventFilterConditions500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetEvents400Response
 */
export interface GetEvents400Response {
    /**
     * 
     * @type {number}
     * @memberof GetEvents400Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetEvents400Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetEvents400Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetEvents500Response
 */
export interface GetEvents500Response {
    /**
     * 
     * @type {number}
     * @memberof GetEvents500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetEvents500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetEvents500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetEventsResponse
 */
export interface GetEventsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetEventsResponse
     */
    'code': number;
    /**
     * 
     * @type {GetEventsResponseData}
     * @memberof GetEventsResponse
     */
    'data': GetEventsResponseData;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetEventsResponseData
 */
export interface GetEventsResponseData {
    /**
     * 
     * @type {Array<GetEventsResponseDataEventsInner>}
     * @memberof GetEventsResponseData
     */
    'events': Array<GetEventsResponseDataEventsInner>;
    /**
     * 
     * @type {GetEventsResponseDataPage}
     * @memberof GetEventsResponseData
     */
    'page': GetEventsResponseDataPage;
}
/**
 * 
 * @export
 * @interface GetEventsResponseDataEventsInner
 */
export interface GetEventsResponseDataEventsInner {
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponseDataEventsInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponseDataEventsInner
     */
    'severity': string;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponseDataEventsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponseDataEventsInner
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponseDataEventsInner
     */
    'host': string;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponseDataEventsInner
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponseDataEventsInner
     */
    'service': string;
    /**
     * 
     * @type {GetEventsResponseDataEventsInnerMetadata}
     * @memberof GetEventsResponseDataEventsInner
     */
    'metadata': GetEventsResponseDataEventsInnerMetadata;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponseDataEventsInner
     */
    'time': string;
}
/**
 * 
 * @export
 * @interface GetEventsResponseDataEventsInnerMetadata
 */
export interface GetEventsResponseDataEventsInnerMetadata {
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponseDataEventsInnerMetadata
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetEventsResponseDataEventsInnerMetadata
     */
    'ip': string;
}
/**
 * 
 * @export
 * @interface GetEventsResponseDataPage
 */
export interface GetEventsResponseDataPage {
    /**
     * 
     * @type {number}
     * @memberof GetEventsResponseDataPage
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof GetEventsResponseDataPage
     */
    'number': number;
    /**
     * 
     * @type {number}
     * @memberof GetEventsResponseDataPage
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface GetHealthHistory500Response
 */
export interface GetHealthHistory500Response {
    /**
     * 
     * @type {number}
     * @memberof GetHealthHistory500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetHealthHistory500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetHealthHistory500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetHealths500Response
 */
export interface GetHealths500Response {
    /**
     * 
     * @type {number}
     * @memberof GetHealths500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetHealths500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetHealths500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetHealthsResponse
 */
export interface GetHealthsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetHealthsResponse
     */
    'code': number;
    /**
     * 
     * @type {GetHealthsResponseData}
     * @memberof GetHealthsResponse
     */
    'data': GetHealthsResponseData;
    /**
     * 
     * @type {string}
     * @memberof GetHealthsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetHealthsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetHealthsResponseData
 */
export interface GetHealthsResponseData {
    /**
     * 
     * @type {GetHealthsResponseDataOverall}
     * @memberof GetHealthsResponseData
     */
    'overall': GetHealthsResponseDataOverall;
    /**
     * 
     * @type {Array<GetHealthsResponseDataServicesInner>}
     * @memberof GetHealthsResponseData
     */
    'services': Array<GetHealthsResponseDataServicesInner>;
}
/**
 * 
 * @export
 * @interface GetHealthsResponseDataOverall
 */
export interface GetHealthsResponseDataOverall {
    /**
     * 
     * @type {GetHealthsResponseDataOverallStatus}
     * @memberof GetHealthsResponseDataOverall
     */
    'status': GetHealthsResponseDataOverallStatus;
}
/**
 * 
 * @export
 * @interface GetHealthsResponseDataOverallStatus
 */
export interface GetHealthsResponseDataOverallStatus {
    /**
     * 
     * @type {string}
     * @memberof GetHealthsResponseDataOverallStatus
     */
    'current': GetHealthsResponseDataOverallStatusCurrentEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GetHealthsResponseDataOverallStatus
     */
    'isFixing': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetHealthsResponseDataOverallStatus
     */
    'description'?: string;
}

export const GetHealthsResponseDataOverallStatusCurrentEnum = {
    Ok: 'ok',
    Ng: 'ng'
} as const;

export type GetHealthsResponseDataOverallStatusCurrentEnum = typeof GetHealthsResponseDataOverallStatusCurrentEnum[keyof typeof GetHealthsResponseDataOverallStatusCurrentEnum];

/**
 * 
 * @export
 * @interface GetHealthsResponseDataServicesInner
 */
export interface GetHealthsResponseDataServicesInner {
    /**
     * 
     * @type {string}
     * @memberof GetHealthsResponseDataServicesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetHealthsResponseDataServicesInner
     */
    'category': string;
    /**
     * 
     * @type {GetHealthsResponseDataServicesInnerStatus}
     * @memberof GetHealthsResponseDataServicesInner
     */
    'status': GetHealthsResponseDataServicesInnerStatus;
    /**
     * 
     * @type {Array<GetHealthsResponseDataServicesInnerModulesInner>}
     * @memberof GetHealthsResponseDataServicesInner
     */
    'modules': Array<GetHealthsResponseDataServicesInnerModulesInner>;
}
/**
 * 
 * @export
 * @interface GetHealthsResponseDataServicesInnerModulesInner
 */
export interface GetHealthsResponseDataServicesInnerModulesInner {
    /**
     * 
     * @type {string}
     * @memberof GetHealthsResponseDataServicesInnerModulesInner
     */
    'name': string;
    /**
     * 
     * @type {GetHealthsResponseDataServicesInnerStatus}
     * @memberof GetHealthsResponseDataServicesInnerModulesInner
     */
    'status': GetHealthsResponseDataServicesInnerStatus;
}
/**
 * 
 * @export
 * @interface GetHealthsResponseDataServicesInnerStatus
 */
export interface GetHealthsResponseDataServicesInnerStatus {
    /**
     * 
     * @type {string}
     * @memberof GetHealthsResponseDataServicesInnerStatus
     */
    'current': GetHealthsResponseDataServicesInnerStatusCurrentEnum;
}

export const GetHealthsResponseDataServicesInnerStatusCurrentEnum = {
    Ok: 'ok',
    Ng: 'ng'
} as const;

export type GetHealthsResponseDataServicesInnerStatusCurrentEnum = typeof GetHealthsResponseDataServicesInnerStatusCurrentEnum[keyof typeof GetHealthsResponseDataServicesInnerStatusCurrentEnum];

/**
 * 
 * @export
 * @interface GetIntegrations500Response
 */
export interface GetIntegrations500Response {
    /**
     * 
     * @type {number}
     * @memberof GetIntegrations500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetIntegrations500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetIntegrations500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetIntegrationsResponse
 */
export interface GetIntegrationsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetIntegrationsResponse
     */
    'code': number;
    /**
     * 
     * @type {Array<GetIntegrationsResponseDataInner>}
     * @memberof GetIntegrationsResponse
     */
    'data': Array<GetIntegrationsResponseDataInner>;
    /**
     * 
     * @type {string}
     * @memberof GetIntegrationsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetIntegrationsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetIntegrationsResponseDataInner
 */
export interface GetIntegrationsResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetIntegrationsResponseDataInner
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetIntegrationsResponseDataInner
     */
    'isHeaderShortcutEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetIntegrationsResponseDataInner
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetIntegrationsResponseDataInner
     */
    'isBuiltIn': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetIntegrationsResponseDataInner
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface GetLicenses500Response
 */
export interface GetLicenses500Response {
    /**
     * 
     * @type {number}
     * @memberof GetLicenses500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetLicenses500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetLicenses500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetLicensesResponse
 */
export interface GetLicensesResponse {
    /**
     * 
     * @type {number}
     * @memberof GetLicensesResponse
     */
    'code': number;
    /**
     * 
     * @type {GetLicensesResponseData}
     * @memberof GetLicensesResponse
     */
    'data': GetLicensesResponseData;
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetLicensesResponseData
 */
export interface GetLicensesResponseData {
    /**
     * 
     * @type {Array<GetLicensesResponseDataLicensesInner>}
     * @memberof GetLicensesResponseData
     */
    'licenses'?: Array<GetLicensesResponseDataLicensesInner>;
    /**
     * 
     * @type {GetLicensesResponseDataPage}
     * @memberof GetLicensesResponseData
     */
    'page'?: GetLicensesResponseDataPage;
}
/**
 * 
 * @export
 * @interface GetLicensesResponseDataLicensesInner
 */
export interface GetLicensesResponseDataLicensesInner {
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponseDataLicensesInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponseDataLicensesInner
     */
    'hostname': string;
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponseDataLicensesInner
     */
    'serial': string;
    /**
     * 
     * @type {GetLicensesResponseDataLicensesInnerProduct}
     * @memberof GetLicensesResponseDataLicensesInner
     */
    'product': GetLicensesResponseDataLicensesInnerProduct;
    /**
     * 
     * @type {GetLicensesResponseDataLicensesInnerIssue}
     * @memberof GetLicensesResponseDataLicensesInner
     */
    'issue': GetLicensesResponseDataLicensesInnerIssue;
    /**
     * 
     * @type {GetLicensesResponseDataLicensesInnerQuantity}
     * @memberof GetLicensesResponseDataLicensesInner
     */
    'quantity': GetLicensesResponseDataLicensesInnerQuantity;
    /**
     * 
     * @type {GetLicensesResponseDataLicensesInnerServiceLevelAgreement}
     * @memberof GetLicensesResponseDataLicensesInner
     */
    'serviceLevelAgreement': GetLicensesResponseDataLicensesInnerServiceLevelAgreement;
    /**
     * 
     * @type {GetLicensesResponseDataLicensesInnerExpiry}
     * @memberof GetLicensesResponseDataLicensesInner
     */
    'expiry': GetLicensesResponseDataLicensesInnerExpiry;
}
/**
 * 
 * @export
 * @interface GetLicensesResponseDataLicensesInnerExpiry
 */
export interface GetLicensesResponseDataLicensesInnerExpiry {
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponseDataLicensesInnerExpiry
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof GetLicensesResponseDataLicensesInnerExpiry
     */
    'days': number;
}
/**
 * 
 * @export
 * @interface GetLicensesResponseDataLicensesInnerIssue
 */
export interface GetLicensesResponseDataLicensesInnerIssue {
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponseDataLicensesInnerIssue
     */
    'by': string;
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponseDataLicensesInnerIssue
     */
    'to': string;
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponseDataLicensesInnerIssue
     */
    'hardware': string;
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponseDataLicensesInnerIssue
     */
    'date': string;
}
/**
 * 
 * @export
 * @interface GetLicensesResponseDataLicensesInnerProduct
 */
export interface GetLicensesResponseDataLicensesInnerProduct {
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponseDataLicensesInnerProduct
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof GetLicensesResponseDataLicensesInnerProduct
     */
    'features': object;
}
/**
 * 
 * @export
 * @interface GetLicensesResponseDataLicensesInnerQuantity
 */
export interface GetLicensesResponseDataLicensesInnerQuantity {
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponseDataLicensesInnerQuantity
     */
    'type': string;
    /**
     * 
     * @type {number}
     * @memberof GetLicensesResponseDataLicensesInnerQuantity
     */
    'vcpu': number;
}
/**
 * 
 * @export
 * @interface GetLicensesResponseDataLicensesInnerServiceLevelAgreement
 */
export interface GetLicensesResponseDataLicensesInnerServiceLevelAgreement {
    /**
     * 
     * @type {number}
     * @memberof GetLicensesResponseDataLicensesInnerServiceLevelAgreement
     */
    'uptime': number;
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponseDataLicensesInnerServiceLevelAgreement
     */
    'period': string;
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponseDataLicensesInnerServiceLevelAgreement
     */
    'meanTimeBetweenFailure': string;
    /**
     * 
     * @type {string}
     * @memberof GetLicensesResponseDataLicensesInnerServiceLevelAgreement
     */
    'meanTimeToRecovery': string;
}
/**
 * 
 * @export
 * @interface GetLicensesResponseDataPage
 */
export interface GetLicensesResponseDataPage {
    /**
     * 
     * @type {number}
     * @memberof GetLicensesResponseDataPage
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof GetLicensesResponseDataPage
     */
    'number': number;
    /**
     * 
     * @type {number}
     * @memberof GetLicensesResponseDataPage
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface GetMe500Response
 */
export interface GetMe500Response {
    /**
     * 
     * @type {number}
     * @memberof GetMe500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetMe500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMe500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetMeResponse
 */
export interface GetMeResponse {
    /**
     * 
     * @type {number}
     * @memberof GetMeResponse
     */
    'code': number;
    /**
     * 
     * @type {GetMeResponseData}
     * @memberof GetMeResponse
     */
    'data': GetMeResponseData;
    /**
     * 
     * @type {string}
     * @memberof GetMeResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetMeResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetMeResponseData
 */
export interface GetMeResponseData {
    /**
     * 
     * @type {string}
     * @memberof GetMeResponseData
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GetMemoryUsageRankOfHostsResponse
 */
export interface GetMemoryUsageRankOfHostsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetMemoryUsageRankOfHostsResponse
     */
    'code': number;
    /**
     * 
     * @type {MetricRank}
     * @memberof GetMemoryUsageRankOfHostsResponse
     */
    'data': MetricRank;
    /**
     * 
     * @type {string}
     * @memberof GetMemoryUsageRankOfHostsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetMemoryUsageRankOfHostsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetMemoryUsageRankOfVmsResponse
 */
export interface GetMemoryUsageRankOfVmsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetMemoryUsageRankOfVmsResponse
     */
    'code': number;
    /**
     * 
     * @type {MetricRank}
     * @memberof GetMemoryUsageRankOfVmsResponse
     */
    'data': MetricRank;
    /**
     * 
     * @type {string}
     * @memberof GetMemoryUsageRankOfVmsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetMemoryUsageRankOfVmsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetMemoryUsageSummaryOfHostsResponse
 */
export interface GetMemoryUsageSummaryOfHostsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetMemoryUsageSummaryOfHostsResponse
     */
    'code': number;
    /**
     * 
     * @type {GetMetricsResponseDataHostUsagesInnerMemory}
     * @memberof GetMemoryUsageSummaryOfHostsResponse
     */
    'data': GetMetricsResponseDataHostUsagesInnerMemory;
    /**
     * 
     * @type {string}
     * @memberof GetMemoryUsageSummaryOfHostsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetMemoryUsageSummaryOfHostsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetMemoryUsageSummaryOfVmsResponse
 */
export interface GetMemoryUsageSummaryOfVmsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetMemoryUsageSummaryOfVmsResponse
     */
    'code': number;
    /**
     * 
     * @type {GetMetricsResponseDataHostUsagesInnerMemory}
     * @memberof GetMemoryUsageSummaryOfVmsResponse
     */
    'data': GetMetricsResponseDataHostUsagesInnerMemory;
    /**
     * 
     * @type {string}
     * @memberof GetMemoryUsageSummaryOfVmsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetMemoryUsageSummaryOfVmsResponse
     */
    'status': string;
}
/**
 * @type GetMetricByTypes200Response
 * @export
 */
export type GetMetricByTypes200Response = GetCpuUsageRankOfHostsResponse | GetCpuUsageRankOfVmsResponse | GetCpuUsageSummaryOfHostsResponse | GetDiskBandwidthHistoryOfHostsResponse | GetDiskIopsHistoryOfHostsResponse | GetDiskLatencyHistoryOfHostsResponse | GetDiskReadIopsRankOfVmsResponse | GetDiskUsageRankOfHostsResponse | GetDiskWriteIopsRankOfVmsResponse | GetMemoryUsageRankOfHostsResponse | GetMemoryUsageRankOfVmsResponse | GetMemoryUsageSummaryOfHostsResponse | GetMemoryUsageSummaryOfVmsResponse | GetNetworkTrafficInRankOfHostsResponse | GetNetworkTrafficInRankOfVmsResponse | GetNetworkTrafficOutRankOfHostsResponse | GetNetworkTrafficOutRankOfVmsResponse;

/**
 * 
 * @export
 * @interface GetMetricByTypes400Response
 */
export interface GetMetricByTypes400Response {
    /**
     * 
     * @type {number}
     * @memberof GetMetricByTypes400Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetMetricByTypes400Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMetricByTypes400Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetMetricsOverview500Response
 */
export interface GetMetricsOverview500Response {
    /**
     * 
     * @type {number}
     * @memberof GetMetricsOverview500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetMetricsOverview500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMetricsOverview500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetMetricsResponse
 */
export interface GetMetricsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponse
     */
    'code': number;
    /**
     * 
     * @type {GetMetricsResponseData}
     * @memberof GetMetricsResponse
     */
    'data': GetMetricsResponseData;
    /**
     * 
     * @type {string}
     * @memberof GetMetricsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetMetricsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseData
 */
export interface GetMetricsResponseData {
    /**
     * 
     * @type {GetMetricsResponseDataDataCenter}
     * @memberof GetMetricsResponseData
     */
    'dataCenter': GetMetricsResponseDataDataCenter;
    /**
     * 
     * @type {GetMetricsResponseDataHost}
     * @memberof GetMetricsResponseData
     */
    'host': GetMetricsResponseDataHost;
    /**
     * 
     * @type {GetMetricsResponseDataVm}
     * @memberof GetMetricsResponseData
     */
    'vm': GetMetricsResponseDataVm;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataDataCenter
 */
export interface GetMetricsResponseDataDataCenter {
    /**
     * 
     * @type {GetMetricsResponseDataDataCenterUsage}
     * @memberof GetMetricsResponseDataDataCenter
     */
    'usage': GetMetricsResponseDataDataCenterUsage;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataDataCenterUsage
 */
export interface GetMetricsResponseDataDataCenterUsage {
    /**
     * 
     * @type {GetMetricsResponseDataDataCenterUsageCpu}
     * @memberof GetMetricsResponseDataDataCenterUsage
     */
    'cpu': GetMetricsResponseDataDataCenterUsageCpu;
    /**
     * 
     * @type {GetMetricsResponseDataDataCenterUsageMemory}
     * @memberof GetMetricsResponseDataDataCenterUsage
     */
    'memory': GetMetricsResponseDataDataCenterUsageMemory;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataDataCenterUsageCpu
 */
export interface GetMetricsResponseDataDataCenterUsageCpu {
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataDataCenterUsageCpu
     */
    'totalCores': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataDataCenterUsageCpu
     */
    'usedCores': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataDataCenterUsageCpu
     */
    'usedPercent': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataDataCenterUsageCpu
     */
    'freeCores': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataDataCenterUsageCpu
     */
    'freePercent': number;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataDataCenterUsageMemory
 */
export interface GetMetricsResponseDataDataCenterUsageMemory {
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataDataCenterUsageMemory
     */
    'totalMiB': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataDataCenterUsageMemory
     */
    'usedMiB': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataDataCenterUsageMemory
     */
    'usedPercent': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataDataCenterUsageMemory
     */
    'freeMiB': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataDataCenterUsageMemory
     */
    'freePercent': number;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataHost
 */
export interface GetMetricsResponseDataHost {
    /**
     * 
     * @type {GetMetricsResponseDataHostRole}
     * @memberof GetMetricsResponseDataHost
     */
    'role': GetMetricsResponseDataHostRole;
    /**
     * 
     * @type {Array<GetMetricsResponseDataHostUsagesInner>}
     * @memberof GetMetricsResponseDataHost
     */
    'usages': Array<GetMetricsResponseDataHostUsagesInner>;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataHostRole
 */
export interface GetMetricsResponseDataHostRole {
    /**
     * 
     * @type {RoleUsage}
     * @memberof GetMetricsResponseDataHostRole
     */
    'controlConverged': RoleUsage;
    /**
     * 
     * @type {RoleUsage}
     * @memberof GetMetricsResponseDataHostRole
     */
    'control': RoleUsage;
    /**
     * 
     * @type {RoleUsage}
     * @memberof GetMetricsResponseDataHostRole
     */
    'compute': RoleUsage;
    /**
     * 
     * @type {RoleUsage}
     * @memberof GetMetricsResponseDataHostRole
     */
    'storage': RoleUsage;
    /**
     * 
     * @type {RoleUsage}
     * @memberof GetMetricsResponseDataHostRole
     */
    'edgeCore': RoleUsage;
    /**
     * 
     * @type {RoleUsage}
     * @memberof GetMetricsResponseDataHostRole
     */
    'moderator': RoleUsage;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataHostUsagesInner
 */
export interface GetMetricsResponseDataHostUsagesInner {
    /**
     * 
     * @type {string}
     * @memberof GetMetricsResponseDataHostUsagesInner
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof GetMetricsResponseDataHostUsagesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetMetricsResponseDataHostUsagesInner
     */
    'address': string;
    /**
     * 
     * @type {GetMetricsResponseDataHostUsagesInnerCpu}
     * @memberof GetMetricsResponseDataHostUsagesInner
     */
    'cpu': GetMetricsResponseDataHostUsagesInnerCpu;
    /**
     * 
     * @type {GetMetricsResponseDataHostUsagesInnerMemory}
     * @memberof GetMetricsResponseDataHostUsagesInner
     */
    'memory': GetMetricsResponseDataHostUsagesInnerMemory;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataHostUsagesInnerCpu
 */
export interface GetMetricsResponseDataHostUsagesInnerCpu {
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataHostUsagesInnerCpu
     */
    'totalCores': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataHostUsagesInnerCpu
     */
    'usedCores': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataHostUsagesInnerCpu
     */
    'usedPercent': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataHostUsagesInnerCpu
     */
    'freeCores': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataHostUsagesInnerCpu
     */
    'freePercent': number;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataHostUsagesInnerMemory
 */
export interface GetMetricsResponseDataHostUsagesInnerMemory {
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataHostUsagesInnerMemory
     */
    'totalMiB': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataHostUsagesInnerMemory
     */
    'usedMiB': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataHostUsagesInnerMemory
     */
    'usedPercent': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataHostUsagesInnerMemory
     */
    'freeMiB': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataHostUsagesInnerMemory
     */
    'freePercent': number;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataVm
 */
export interface GetMetricsResponseDataVm {
    /**
     * 
     * @type {GetMetricsResponseDataVmStatus}
     * @memberof GetMetricsResponseDataVm
     */
    'status': GetMetricsResponseDataVmStatus;
    /**
     * 
     * @type {GetMetricsResponseDataVmUsage}
     * @memberof GetMetricsResponseDataVm
     */
    'usage': GetMetricsResponseDataVmUsage;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataVmStatus
 */
export interface GetMetricsResponseDataVmStatus {
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmStatus
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmStatus
     */
    'running': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmStatus
     */
    'stopped': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmStatus
     */
    'paused': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmStatus
     */
    'suspend': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmStatus
     */
    'error': number;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataVmUsage
 */
export interface GetMetricsResponseDataVmUsage {
    /**
     * 
     * @type {GetMetricsResponseDataVmUsageVcpu}
     * @memberof GetMetricsResponseDataVmUsage
     */
    'vcpu': GetMetricsResponseDataVmUsageVcpu;
    /**
     * 
     * @type {GetMetricsResponseDataVmUsageMemory}
     * @memberof GetMetricsResponseDataVmUsage
     */
    'memory': GetMetricsResponseDataVmUsageMemory;
    /**
     * 
     * @type {GetMetricsResponseDataVmUsageStorage}
     * @memberof GetMetricsResponseDataVmUsage
     */
    'storage': GetMetricsResponseDataVmUsageStorage;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataVmUsageMemory
 */
export interface GetMetricsResponseDataVmUsageMemory {
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageMemory
     */
    'totalMiB': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageMemory
     */
    'usedMiB': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageMemory
     */
    'freeMiB': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageMemory
     */
    'usedPercent': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageMemory
     */
    'freePercent': number;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataVmUsageStorage
 */
export interface GetMetricsResponseDataVmUsageStorage {
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageStorage
     */
    'totalMiB': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageStorage
     */
    'usedMiB': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageStorage
     */
    'freeMiB': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageStorage
     */
    'usedPercent': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageStorage
     */
    'freePercent': number;
}
/**
 * 
 * @export
 * @interface GetMetricsResponseDataVmUsageVcpu
 */
export interface GetMetricsResponseDataVmUsageVcpu {
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageVcpu
     */
    'totalCores': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageVcpu
     */
    'usedCores': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageVcpu
     */
    'freeCores': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageVcpu
     */
    'usedPercent': number;
    /**
     * 
     * @type {number}
     * @memberof GetMetricsResponseDataVmUsageVcpu
     */
    'freePercent': number;
}
/**
 * 
 * @export
 * @interface GetModuleHealthHistoryResponse
 */
export interface GetModuleHealthHistoryResponse {
    /**
     * 
     * @type {number}
     * @memberof GetModuleHealthHistoryResponse
     */
    'code': number;
    /**
     * 
     * @type {GetModuleHealthHistoryResponseData}
     * @memberof GetModuleHealthHistoryResponse
     */
    'data': GetModuleHealthHistoryResponseData;
    /**
     * 
     * @type {string}
     * @memberof GetModuleHealthHistoryResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetModuleHealthHistoryResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetModuleHealthHistoryResponseData
 */
export interface GetModuleHealthHistoryResponseData {
    /**
     * 
     * @type {string}
     * @memberof GetModuleHealthHistoryResponseData
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof GetModuleHealthHistoryResponseData
     */
    'service'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetModuleHealthHistoryResponseData
     */
    'module': string;
    /**
     * 
     * @type {Array<GetModuleHealthHistoryResponseDataHistoryInner>}
     * @memberof GetModuleHealthHistoryResponseData
     */
    'history': Array<GetModuleHealthHistoryResponseDataHistoryInner>;
}
/**
 * 
 * @export
 * @interface GetModuleHealthHistoryResponseDataHistoryInner
 */
export interface GetModuleHealthHistoryResponseDataHistoryInner {
    /**
     * 
     * @type {string}
     * @memberof GetModuleHealthHistoryResponseDataHistoryInner
     */
    'time': string;
    /**
     * 
     * @type {string}
     * @memberof GetModuleHealthHistoryResponseDataHistoryInner
     */
    'status': GetModuleHealthHistoryResponseDataHistoryInnerStatusEnum;
    /**
     * 
     * @type {GetModuleHealthHistoryResponseDataHistoryInnerError}
     * @memberof GetModuleHealthHistoryResponseDataHistoryInner
     */
    'error'?: GetModuleHealthHistoryResponseDataHistoryInnerError;
}

export const GetModuleHealthHistoryResponseDataHistoryInnerStatusEnum = {
    Ok: 'ok',
    Ng: 'ng'
} as const;

export type GetModuleHealthHistoryResponseDataHistoryInnerStatusEnum = typeof GetModuleHealthHistoryResponseDataHistoryInnerStatusEnum[keyof typeof GetModuleHealthHistoryResponseDataHistoryInnerStatusEnum];

/**
 * 
 * @export
 * @interface GetModuleHealthHistoryResponseDataHistoryInnerError
 */
export interface GetModuleHealthHistoryResponseDataHistoryInnerError {
    /**
     * 
     * @type {string}
     * @memberof GetModuleHealthHistoryResponseDataHistoryInnerError
     */
    'type'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetModuleHealthHistoryResponseDataHistoryInnerError
     */
    'nodes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetModuleHealthHistoryResponseDataHistoryInnerError
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetModuleHealthHistoryResponseDataHistoryInnerError
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetModuleHealthHistoryResponseDataHistoryInnerError
     */
    'log'?: string;
}
/**
 * 
 * @export
 * @interface GetNetworkTrafficInRankOfHostsResponse
 */
export interface GetNetworkTrafficInRankOfHostsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetNetworkTrafficInRankOfHostsResponse
     */
    'code': number;
    /**
     * 
     * @type {MetricRank}
     * @memberof GetNetworkTrafficInRankOfHostsResponse
     */
    'data': MetricRank;
    /**
     * 
     * @type {string}
     * @memberof GetNetworkTrafficInRankOfHostsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetNetworkTrafficInRankOfHostsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetNetworkTrafficInRankOfVmsResponse
 */
export interface GetNetworkTrafficInRankOfVmsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetNetworkTrafficInRankOfVmsResponse
     */
    'code': number;
    /**
     * 
     * @type {MetricRank}
     * @memberof GetNetworkTrafficInRankOfVmsResponse
     */
    'data': MetricRank;
    /**
     * 
     * @type {string}
     * @memberof GetNetworkTrafficInRankOfVmsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetNetworkTrafficInRankOfVmsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetNetworkTrafficOutRankOfHostsResponse
 */
export interface GetNetworkTrafficOutRankOfHostsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetNetworkTrafficOutRankOfHostsResponse
     */
    'code': number;
    /**
     * 
     * @type {MetricRank}
     * @memberof GetNetworkTrafficOutRankOfHostsResponse
     */
    'data': MetricRank;
    /**
     * 
     * @type {string}
     * @memberof GetNetworkTrafficOutRankOfHostsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetNetworkTrafficOutRankOfHostsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetNetworkTrafficOutRankOfVmsResponse
 */
export interface GetNetworkTrafficOutRankOfVmsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetNetworkTrafficOutRankOfVmsResponse
     */
    'code': number;
    /**
     * 
     * @type {MetricRank}
     * @memberof GetNetworkTrafficOutRankOfVmsResponse
     */
    'data': MetricRank;
    /**
     * 
     * @type {string}
     * @memberof GetNetworkTrafficOutRankOfVmsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetNetworkTrafficOutRankOfVmsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetNodesResponse
 */
export interface GetNodesResponse {
    /**
     * 
     * @type {number}
     * @memberof GetNodesResponse
     */
    'code': number;
    /**
     * 
     * @type {GetNodesResponseData}
     * @memberof GetNodesResponse
     */
    'data': GetNodesResponseData;
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetNodesResponseData
 */
export interface GetNodesResponseData {
    /**
     * 
     * @type {Array<GetNodesResponseDataNodesInner>}
     * @memberof GetNodesResponseData
     */
    'nodes': Array<GetNodesResponseDataNodesInner>;
    /**
     * 
     * @type {GetEventsResponseDataPage}
     * @memberof GetNodesResponseData
     */
    'page': GetEventsResponseDataPage;
}
/**
 * 
 * @export
 * @interface GetNodesResponseDataNodesInner
 */
export interface GetNodesResponseDataNodesInner {
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponseDataNodesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponseDataNodesInner
     */
    'hostname': string;
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponseDataNodesInner
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponseDataNodesInner
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponseDataNodesInner
     */
    'managementIP': string;
    /**
     * 
     * @type {GetNodesResponseDataNodesInnerLicense}
     * @memberof GetNodesResponseDataNodesInner
     */
    'license': GetNodesResponseDataNodesInnerLicense;
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponseDataNodesInner
     */
    'status': string;
    /**
     * 
     * @type {GetNodesResponseDataNodesInnerVcpu}
     * @memberof GetNodesResponseDataNodesInner
     */
    'vcpu': GetNodesResponseDataNodesInnerVcpu;
    /**
     * 
     * @type {GetNodesResponseDataNodesInnerMemory}
     * @memberof GetNodesResponseDataNodesInner
     */
    'memory': GetNodesResponseDataNodesInnerMemory;
    /**
     * 
     * @type {GetNodesResponseDataNodesInnerMemory}
     * @memberof GetNodesResponseDataNodesInner
     */
    'storage': GetNodesResponseDataNodesInnerMemory;
    /**
     * 
     * @type {number}
     * @memberof GetNodesResponseDataNodesInner
     */
    'uptimeSeconds': number;
    /**
     * 
     * @type {GetNodesResponseDataNodesInnerLabels}
     * @memberof GetNodesResponseDataNodesInner
     */
    'labels': GetNodesResponseDataNodesInnerLabels;
}
/**
 * 
 * @export
 * @interface GetNodesResponseDataNodesInnerLabels
 */
export interface GetNodesResponseDataNodesInnerLabels {
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponseDataNodesInnerLabels
     */
    'isGpuEnabled': string;
}
/**
 * 
 * @export
 * @interface GetNodesResponseDataNodesInnerLicense
 */
export interface GetNodesResponseDataNodesInnerLicense {
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponseDataNodesInnerLicense
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponseDataNodesInnerLicense
     */
    'hostname': string;
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponseDataNodesInnerLicense
     */
    'serial': string;
    /**
     * 
     * @type {GetNodesResponseDataNodesInnerLicenseProduct}
     * @memberof GetNodesResponseDataNodesInnerLicense
     */
    'product': GetNodesResponseDataNodesInnerLicenseProduct;
    /**
     * 
     * @type {GetLicensesResponseDataLicensesInnerIssue}
     * @memberof GetNodesResponseDataNodesInnerLicense
     */
    'issue': GetLicensesResponseDataLicensesInnerIssue;
    /**
     * 
     * @type {GetNodesResponseDataNodesInnerLicenseServiceLevelAgreement}
     * @memberof GetNodesResponseDataNodesInnerLicense
     */
    'serviceLevelAgreement': GetNodesResponseDataNodesInnerLicenseServiceLevelAgreement;
    /**
     * 
     * @type {GetLicensesResponseDataLicensesInnerExpiry}
     * @memberof GetNodesResponseDataNodesInnerLicense
     */
    'expiry': GetLicensesResponseDataLicensesInnerExpiry;
}
/**
 * 
 * @export
 * @interface GetNodesResponseDataNodesInnerLicenseProduct
 */
export interface GetNodesResponseDataNodesInnerLicenseProduct {
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponseDataNodesInnerLicenseProduct
     */
    'name': string;
    /**
     * 
     * @type {GetMeResponseData}
     * @memberof GetNodesResponseDataNodesInnerLicenseProduct
     */
    'features': GetMeResponseData;
}
/**
 * 
 * @export
 * @interface GetNodesResponseDataNodesInnerLicenseServiceLevelAgreement
 */
export interface GetNodesResponseDataNodesInnerLicenseServiceLevelAgreement {
    /**
     * 
     * @type {number}
     * @memberof GetNodesResponseDataNodesInnerLicenseServiceLevelAgreement
     */
    'uptime': number;
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponseDataNodesInnerLicenseServiceLevelAgreement
     */
    'period': string;
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponseDataNodesInnerLicenseServiceLevelAgreement
     */
    'meanTimeBetweenFailure': string;
    /**
     * 
     * @type {string}
     * @memberof GetNodesResponseDataNodesInnerLicenseServiceLevelAgreement
     */
    'meanTimeToRepair': string;
}
/**
 * 
 * @export
 * @interface GetNodesResponseDataNodesInnerMemory
 */
export interface GetNodesResponseDataNodesInnerMemory {
    /**
     * 
     * @type {number}
     * @memberof GetNodesResponseDataNodesInnerMemory
     */
    'totalMiB': number;
    /**
     * 
     * @type {number}
     * @memberof GetNodesResponseDataNodesInnerMemory
     */
    'usedMiB': number;
    /**
     * 
     * @type {number}
     * @memberof GetNodesResponseDataNodesInnerMemory
     */
    'freeMiB': number;
}
/**
 * 
 * @export
 * @interface GetNodesResponseDataNodesInnerVcpu
 */
export interface GetNodesResponseDataNodesInnerVcpu {
    /**
     * 
     * @type {number}
     * @memberof GetNodesResponseDataNodesInnerVcpu
     */
    'totalCores': number;
    /**
     * 
     * @type {number}
     * @memberof GetNodesResponseDataNodesInnerVcpu
     */
    'usedCores': number;
    /**
     * 
     * @type {number}
     * @memberof GetNodesResponseDataNodesInnerVcpu
     */
    'freeCores': number;
}
/**
 * 
 * @export
 * @interface GetRankedEventsResponse
 */
export interface GetRankedEventsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetRankedEventsResponse
     */
    'code': number;
    /**
     * 
     * @type {GetRankedEventsResponseData}
     * @memberof GetRankedEventsResponse
     */
    'data': GetRankedEventsResponseData;
    /**
     * 
     * @type {string}
     * @memberof GetRankedEventsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetRankedEventsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetRankedEventsResponseData
 */
export interface GetRankedEventsResponseData {
    /**
     * 
     * @type {Array<GetRankedEventsResponseDataEventsInner>}
     * @memberof GetRankedEventsResponseData
     */
    'events': Array<GetRankedEventsResponseDataEventsInner>;
    /**
     * 
     * @type {GetAbstractedEventsResponseDataLimit}
     * @memberof GetRankedEventsResponseData
     */
    'limit': GetAbstractedEventsResponseDataLimit;
}
/**
 * 
 * @export
 * @interface GetRankedEventsResponseDataEventsInner
 */
export interface GetRankedEventsResponseDataEventsInner {
    /**
     * 
     * @type {string}
     * @memberof GetRankedEventsResponseDataEventsInner
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof GetRankedEventsResponseDataEventsInner
     */
    'percent': number;
    /**
     * 
     * @type {number}
     * @memberof GetRankedEventsResponseDataEventsInner
     */
    'number': number;
    /**
     * 
     * @type {string}
     * @memberof GetRankedEventsResponseDataEventsInner
     */
    'query': string;
}
/**
 * 
 * @export
 * @interface GetServiceHealthHistory400Response
 */
export interface GetServiceHealthHistory400Response {
    /**
     * 
     * @type {number}
     * @memberof GetServiceHealthHistory400Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetServiceHealthHistory400Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetServiceHealthHistory400Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetServiceHealthHistoryResponse
 */
export interface GetServiceHealthHistoryResponse {
    /**
     * 
     * @type {number}
     * @memberof GetServiceHealthHistoryResponse
     */
    'code': number;
    /**
     * 
     * @type {Array<GetServiceHealthHistoryResponseDataInner>}
     * @memberof GetServiceHealthHistoryResponse
     */
    'data': Array<GetServiceHealthHistoryResponseDataInner>;
    /**
     * 
     * @type {string}
     * @memberof GetServiceHealthHistoryResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetServiceHealthHistoryResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetServiceHealthHistoryResponseDataInner
 */
export interface GetServiceHealthHistoryResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetServiceHealthHistoryResponseDataInner
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof GetServiceHealthHistoryResponseDataInner
     */
    'service': string;
    /**
     * 
     * @type {Array<GetServiceHealthHistoryResponseDataInnerHistoryInner>}
     * @memberof GetServiceHealthHistoryResponseDataInner
     */
    'history': Array<GetServiceHealthHistoryResponseDataInnerHistoryInner>;
    /**
     * 
     * @type {string}
     * @memberof GetServiceHealthHistoryResponseDataInner
     */
    'module': string;
}
/**
 * 
 * @export
 * @interface GetServiceHealthHistoryResponseDataInnerHistoryInner
 */
export interface GetServiceHealthHistoryResponseDataInnerHistoryInner {
    /**
     * 
     * @type {string}
     * @memberof GetServiceHealthHistoryResponseDataInnerHistoryInner
     */
    'time': string;
    /**
     * 
     * @type {string}
     * @memberof GetServiceHealthHistoryResponseDataInnerHistoryInner
     */
    'status': GetServiceHealthHistoryResponseDataInnerHistoryInnerStatusEnum;
    /**
     * 
     * @type {GetServiceHealthHistoryResponseDataInnerHistoryInnerError}
     * @memberof GetServiceHealthHistoryResponseDataInnerHistoryInner
     */
    'error'?: GetServiceHealthHistoryResponseDataInnerHistoryInnerError;
}

export const GetServiceHealthHistoryResponseDataInnerHistoryInnerStatusEnum = {
    Ok: 'ok',
    Ng: 'ng'
} as const;

export type GetServiceHealthHistoryResponseDataInnerHistoryInnerStatusEnum = typeof GetServiceHealthHistoryResponseDataInnerHistoryInnerStatusEnum[keyof typeof GetServiceHealthHistoryResponseDataInnerHistoryInnerStatusEnum];

/**
 * 
 * @export
 * @interface GetServiceHealthHistoryResponseDataInnerHistoryInnerError
 */
export interface GetServiceHealthHistoryResponseDataInnerHistoryInnerError {
    /**
     * 
     * @type {string}
     * @memberof GetServiceHealthHistoryResponseDataInnerHistoryInnerError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetServiceHealthHistoryResponseDataInnerHistoryInnerError
     */
    'reason'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetServiceHealthHistoryResponseDataInnerHistoryInnerError
     */
    'nodes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetServiceHealthHistoryResponseDataInnerHistoryInnerError
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetServiceHealthHistoryResponseDataInnerHistoryInnerError
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetServiceHealthHistoryResponseDataInnerHistoryInnerError
     */
    'log'?: string;
}
/**
 * 
 * @export
 * @interface GetServices500Response
 */
export interface GetServices500Response {
    /**
     * 
     * @type {number}
     * @memberof GetServices500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetServices500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetServices500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetServicesResponse
 */
export interface GetServicesResponse {
    /**
     * 
     * @type {number}
     * @memberof GetServicesResponse
     */
    'code': number;
    /**
     * 
     * @type {Array<GetServicesResponseDataInner>}
     * @memberof GetServicesResponse
     */
    'data': Array<GetServicesResponseDataInner>;
    /**
     * 
     * @type {string}
     * @memberof GetServicesResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetServicesResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetServicesResponseDataInner
 */
export interface GetServicesResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetServicesResponseDataInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetServicesResponseDataInner
     */
    'category': string;
    /**
     * 
     * @type {Array<GetMeResponseData>}
     * @memberof GetServicesResponseDataInner
     */
    'modules': Array<GetMeResponseData>;
}
/**
 * 
 * @export
 * @interface GetSettingResponse
 */
export interface GetSettingResponse {
    /**
     * 
     * @type {number}
     * @memberof GetSettingResponse
     */
    'code': number;
    /**
     * 
     * @type {GetSettingResponseData}
     * @memberof GetSettingResponse
     */
    'data': GetSettingResponseData;
    /**
     * 
     * @type {string}
     * @memberof GetSettingResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetSettingResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetSettingResponseData
 */
export interface GetSettingResponseData {
    /**
     * 
     * @type {string}
     * @memberof GetSettingResponseData
     */
    'titlePrefix': string;
    /**
     * 
     * @type {GetSettingResponseDataEmail}
     * @memberof GetSettingResponseData
     */
    'email': GetSettingResponseDataEmail;
    /**
     * 
     * @type {GetSettingResponseDataSlack}
     * @memberof GetSettingResponseData
     */
    'slack': GetSettingResponseDataSlack;
}
/**
 * 
 * @export
 * @interface GetSettingResponseDataEmail
 */
export interface GetSettingResponseDataEmail {
    /**
     * 
     * @type {Array<EmailSender>}
     * @memberof GetSettingResponseDataEmail
     */
    'senders': Array<EmailSender>;
    /**
     * 
     * @type {Array<EmailRecipient>}
     * @memberof GetSettingResponseDataEmail
     */
    'recipients': Array<EmailRecipient>;
}
/**
 * 
 * @export
 * @interface GetSettingResponseDataSlack
 */
export interface GetSettingResponseDataSlack {
    /**
     * 
     * @type {SlackChannel}
     * @memberof GetSettingResponseDataSlack
     */
    'channel'?: SlackChannel;
}
/**
 * 
 * @export
 * @interface GetSettings500Response
 */
export interface GetSettings500Response {
    /**
     * 
     * @type {number}
     * @memberof GetSettings500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetSettings500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSettings500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetSlackChannels500Response
 */
export interface GetSlackChannels500Response {
    /**
     * 
     * @type {number}
     * @memberof GetSlackChannels500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetSlackChannels500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSlackChannels500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetSlackChannelsResponse
 */
export interface GetSlackChannelsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetSlackChannelsResponse
     */
    'code': number;
    /**
     * 
     * @type {Array<SlackChannel>}
     * @memberof GetSlackChannelsResponse
     */
    'data': Array<SlackChannel>;
    /**
     * 
     * @type {string}
     * @memberof GetSlackChannelsResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetSlackChannelsResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetToken401Response
 */
export interface GetToken401Response {
    /**
     * 
     * @type {number}
     * @memberof GetToken401Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetToken401Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetToken401Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetToken500Response
 */
export interface GetToken500Response {
    /**
     * 
     * @type {number}
     * @memberof GetToken500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetToken500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetToken500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetTokensRequest
 */
export interface GetTokensRequest {
    /**
     * the name of user to generate the token
     * @type {string}
     * @memberof GetTokensRequest
     */
    'name': string;
    /**
     * the password of user to generate the token
     * @type {string}
     * @memberof GetTokensRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface GetTokensResponse
 */
export interface GetTokensResponse {
    /**
     * 
     * @type {number}
     * @memberof GetTokensResponse
     */
    'code': number;
    /**
     * 
     * @type {GetTokensResponseData}
     * @memberof GetTokensResponse
     */
    'data': GetTokensResponseData;
    /**
     * 
     * @type {string}
     * @memberof GetTokensResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof GetTokensResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface GetTokensResponseData
 */
export interface GetTokensResponseData {
    /**
     * 
     * @type {string}
     * @memberof GetTokensResponseData
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof GetTokensResponseData
     */
    'refresh': string;
    /**
     * 
     * @type {GetTokensResponseDataExpires}
     * @memberof GetTokensResponseData
     */
    'expires': GetTokensResponseDataExpires;
}
/**
 * 
 * @export
 * @interface GetTokensResponseDataExpires
 */
export interface GetTokensResponseDataExpires {
    /**
     * 
     * @type {number}
     * @memberof GetTokensResponseDataExpires
     */
    'access': number;
    /**
     * 
     * @type {number}
     * @memberof GetTokensResponseDataExpires
     */
    'refresh': number;
}
/**
 * 
 * @export
 * @interface ImportClusterLicense500Response
 */
export interface ImportClusterLicense500Response {
    /**
     * 
     * @type {number}
     * @memberof ImportClusterLicense500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportClusterLicense500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportClusterLicense500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListTuningResponse
 */
export interface ListTuningResponse {
    /**
     * 
     * @type {number}
     * @memberof ListTuningResponse
     */
    'code'?: number;
    /**
     * 
     * @type {Array<ListTuningResponseDataInner>}
     * @memberof ListTuningResponse
     */
    'data'?: Array<ListTuningResponseDataInner>;
    /**
     * 
     * @type {string}
     * @memberof ListTuningResponse
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListTuningResponse
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListTuningResponseDataInner
 */
export interface ListTuningResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof ListTuningResponseDataInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListTuningResponseDataInner
     */
    'value': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListTuningResponseDataInner
     */
    'hosts': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ListTuningResponseDataInner
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListTuningResponseDataInner
     */
    'enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ListTuningResponseDataInner
     */
    'isModified': boolean;
    /**
     * 
     * @type {ListTuningResponseDataInnerLimitation}
     * @memberof ListTuningResponseDataInner
     */
    'limitation': ListTuningResponseDataInnerLimitation;
}
/**
 * 
 * @export
 * @interface ListTuningResponseDataInnerLimitation
 */
export interface ListTuningResponseDataInnerLimitation {
    /**
     * 
     * @type {string}
     * @memberof ListTuningResponseDataInnerLimitation
     */
    'type': string;
    /**
     * 
     * @type {ListTuningResponseDataInnerLimitationDefault}
     * @memberof ListTuningResponseDataInnerLimitation
     */
    'default': ListTuningResponseDataInnerLimitationDefault;
    /**
     * 
     * @type {ListTuningResponseDataInnerLimitationMin}
     * @memberof ListTuningResponseDataInnerLimitation
     */
    'min': ListTuningResponseDataInnerLimitationMin;
    /**
     * 
     * @type {ListTuningResponseDataInnerLimitationMin}
     * @memberof ListTuningResponseDataInnerLimitation
     */
    'max': ListTuningResponseDataInnerLimitationMin;
}
/**
 * @type ListTuningResponseDataInnerLimitationDefault
 * @export
 */
export type ListTuningResponseDataInnerLimitationDefault = boolean | number | string;

/**
 * @type ListTuningResponseDataInnerLimitationMin
 * @export
 */
export type ListTuningResponseDataInnerLimitationMin = number;

/**
 * 
 * @export
 * @interface ListTuningSpecResponse
 */
export interface ListTuningSpecResponse {
    /**
     * 
     * @type {number}
     * @memberof ListTuningSpecResponse
     */
    'code'?: number;
    /**
     * 
     * @type {Array<ListTuningSpecResponseDataInner>}
     * @memberof ListTuningSpecResponse
     */
    'data'?: Array<ListTuningSpecResponseDataInner>;
    /**
     * 
     * @type {string}
     * @memberof ListTuningSpecResponse
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListTuningSpecResponse
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListTuningSpecResponseDataInner
 */
export interface ListTuningSpecResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof ListTuningSpecResponseDataInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListTuningSpecResponseDataInner
     */
    'description': string;
    /**
     * 
     * @type {ListTuningSpecResponseDataInnerLimitation}
     * @memberof ListTuningSpecResponseDataInner
     */
    'limitation': ListTuningSpecResponseDataInnerLimitation;
    /**
     * 
     * @type {Array<ListTuningSpecResponseDataInnerRolesInner>}
     * @memberof ListTuningSpecResponseDataInner
     */
    'roles': Array<ListTuningSpecResponseDataInnerRolesInner>;
}
/**
 * 
 * @export
 * @interface ListTuningSpecResponseDataInnerLimitation
 */
export interface ListTuningSpecResponseDataInnerLimitation {
    /**
     * 
     * @type {string}
     * @memberof ListTuningSpecResponseDataInnerLimitation
     */
    'type': string;
    /**
     * 
     * @type {ListTuningResponseDataInnerLimitationDefault}
     * @memberof ListTuningSpecResponseDataInnerLimitation
     */
    'default': ListTuningResponseDataInnerLimitationDefault;
    /**
     * 
     * @type {ListTuningResponseDataInnerLimitationMin}
     * @memberof ListTuningSpecResponseDataInnerLimitation
     */
    'min'?: ListTuningResponseDataInnerLimitationMin;
    /**
     * 
     * @type {ListTuningResponseDataInnerLimitationMin}
     * @memberof ListTuningSpecResponseDataInnerLimitation
     */
    'max'?: ListTuningResponseDataInnerLimitationMin;
}
/**
 * 
 * @export
 * @interface ListTuningSpecResponseDataInnerRolesInner
 */
export interface ListTuningSpecResponseDataInnerRolesInner {
    /**
     * 
     * @type {string}
     * @memberof ListTuningSpecResponseDataInnerRolesInner
     */
    'name'?: string;
    /**
     * 
     * @type {Array<ListTuningSpecResponseDataInnerRolesInnerHostsInner>}
     * @memberof ListTuningSpecResponseDataInnerRolesInner
     */
    'hosts'?: Array<ListTuningSpecResponseDataInnerRolesInnerHostsInner>;
}
/**
 * 
 * @export
 * @interface ListTuningSpecResponseDataInnerRolesInnerHostsInner
 */
export interface ListTuningSpecResponseDataInnerRolesInnerHostsInner {
    /**
     * 
     * @type {string}
     * @memberof ListTuningSpecResponseDataInnerRolesInnerHostsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListTuningSpecResponseDataInnerRolesInnerHostsInner
     */
    'ip': string;
}
/**
 * 
 * @export
 * @interface ListTuningSpecs500Response
 */
export interface ListTuningSpecs500Response {
    /**
     * 
     * @type {number}
     * @memberof ListTuningSpecs500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListTuningSpecs500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListTuningSpecs500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ListTunings500Response
 */
export interface ListTunings500Response {
    /**
     * 
     * @type {number}
     * @memberof ListTunings500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListTunings500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListTunings500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface MetricRank
 */
export interface MetricRank {
    /**
     * 
     * @type {string}
     * @memberof MetricRank
     */
    'unit': string;
    /**
     * 
     * @type {Array<MetricRankRankInner>}
     * @memberof MetricRank
     */
    'rank': Array<MetricRankRankInner>;
}
/**
 * 
 * @export
 * @interface MetricRankRankInner
 */
export interface MetricRankRankInner {
    /**
     * 
     * @type {string}
     * @memberof MetricRankRankInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricRankRankInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MetricRankRankInner
     */
    'device'?: string;
    /**
     * 
     * @type {number}
     * @memberof MetricRankRankInner
     */
    'value': number;
    /**
     * 
     * @type {Array<MetricRankRankInnerHistoryInner>}
     * @memberof MetricRankRankInner
     */
    'history': Array<MetricRankRankInnerHistoryInner>;
}
/**
 * 
 * @export
 * @interface MetricRankRankInnerHistoryInner
 */
export interface MetricRankRankInnerHistoryInner {
    /**
     * 
     * @type {string}
     * @memberof MetricRankRankInnerHistoryInner
     */
    'time': string;
    /**
     * 
     * @type {number}
     * @memberof MetricRankRankInnerHistoryInner
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface PatchModuleRepairResponse
 */
export interface PatchModuleRepairResponse {
    /**
     * 
     * @type {number}
     * @memberof PatchModuleRepairResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof PatchModuleRepairResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof PatchModuleRepairResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface PatchRepairResponse
 */
export interface PatchRepairResponse {
    /**
     * 
     * @type {number}
     * @memberof PatchRepairResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof PatchRepairResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof PatchRepairResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface PostEmailRecipientResponse
 */
export interface PostEmailRecipientResponse {
    /**
     * 
     * @type {number}
     * @memberof PostEmailRecipientResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof PostEmailRecipientResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof PostEmailRecipientResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface PostEmailSenderResponse
 */
export interface PostEmailSenderResponse {
    /**
     * 
     * @type {number}
     * @memberof PostEmailSenderResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof PostEmailSenderResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof PostEmailSenderResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface PostLicenseResponse
 */
export interface PostLicenseResponse {
    /**
     * 
     * @type {number}
     * @memberof PostLicenseResponse
     */
    'code': number;
    /**
     * 
     * @type {object}
     * @memberof PostLicenseResponse
     */
    'data'?: object;
    /**
     * 
     * @type {string}
     * @memberof PostLicenseResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof PostLicenseResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface PostSlackChannelResponse
 */
export interface PostSlackChannelResponse {
    /**
     * 
     * @type {number}
     * @memberof PostSlackChannelResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof PostSlackChannelResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof PostSlackChannelResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface PutEmailRecipientResponse
 */
export interface PutEmailRecipientResponse {
    /**
     * 
     * @type {number}
     * @memberof PutEmailRecipientResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof PutEmailRecipientResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof PutEmailRecipientResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface PutEmailSenderResponse
 */
export interface PutEmailSenderResponse {
    /**
     * 
     * @type {number}
     * @memberof PutEmailSenderResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof PutEmailSenderResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof PutEmailSenderResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface PutSlackChannelResponse
 */
export interface PutSlackChannelResponse {
    /**
     * 
     * @type {number}
     * @memberof PutSlackChannelResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof PutSlackChannelResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof PutSlackChannelResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface RepairAllModulesHealth409Response
 */
export interface RepairAllModulesHealth409Response {
    /**
     * 
     * @type {number}
     * @memberof RepairAllModulesHealth409Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof RepairAllModulesHealth409Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepairAllModulesHealth409Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface RepairAllModulesHealth500Response
 */
export interface RepairAllModulesHealth500Response {
    /**
     * 
     * @type {number}
     * @memberof RepairAllModulesHealth500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof RepairAllModulesHealth500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepairAllModulesHealth500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ResetTuning400Response
 */
export interface ResetTuning400Response {
    /**
     * 
     * @type {number}
     * @memberof ResetTuning400Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResetTuning400Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResetTuning400Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ResetTuning500Response
 */
export interface ResetTuning500Response {
    /**
     * 
     * @type {number}
     * @memberof ResetTuning500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResetTuning500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResetTuning500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ResetTuningRequest
 */
export interface ResetTuningRequest {
    /**
     * 
     * @type {Array<ResetTuningRequestRolesInner>}
     * @memberof ResetTuningRequest
     */
    'roles': Array<ResetTuningRequestRolesInner>;
}
/**
 * 
 * @export
 * @interface ResetTuningRequestRolesInner
 */
export interface ResetTuningRequestRolesInner {
    /**
     * 
     * @type {string}
     * @memberof ResetTuningRequestRolesInner
     */
    'name': string;
    /**
     * 
     * @type {Array<GetMeResponseData>}
     * @memberof ResetTuningRequestRolesInner
     */
    'hosts': Array<GetMeResponseData>;
}
/**
 * 
 * @export
 * @interface ResetTuningResponse
 */
export interface ResetTuningResponse {
    /**
     * 
     * @type {number}
     * @memberof ResetTuningResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ResetTuningResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ResetTuningResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface RoleUsage
 */
export interface RoleUsage {
    /**
     * 
     * @type {number}
     * @memberof RoleUsage
     */
    'count': number;
    /**
     * 
     * @type {RoleUsageCpu}
     * @memberof RoleUsage
     */
    'cpu': RoleUsageCpu;
    /**
     * 
     * @type {RoleUsageMemory}
     * @memberof RoleUsage
     */
    'memory': RoleUsageMemory;
}
/**
 * 
 * @export
 * @interface RoleUsageCpu
 */
export interface RoleUsageCpu {
    /**
     * 
     * @type {number}
     * @memberof RoleUsageCpu
     */
    'totalCores': number;
    /**
     * 
     * @type {number}
     * @memberof RoleUsageCpu
     */
    'usedCores': number;
    /**
     * 
     * @type {number}
     * @memberof RoleUsageCpu
     */
    'freeCores': number;
    /**
     * 
     * @type {number}
     * @memberof RoleUsageCpu
     */
    'usedPercent': number;
    /**
     * 
     * @type {number}
     * @memberof RoleUsageCpu
     */
    'freePercent': number;
}
/**
 * 
 * @export
 * @interface RoleUsageMemory
 */
export interface RoleUsageMemory {
    /**
     * 
     * @type {number}
     * @memberof RoleUsageMemory
     */
    'totalMiB': number;
    /**
     * 
     * @type {number}
     * @memberof RoleUsageMemory
     */
    'usedMiB': number;
    /**
     * 
     * @type {number}
     * @memberof RoleUsageMemory
     */
    'freeMiB': number;
    /**
     * 
     * @type {number}
     * @memberof RoleUsageMemory
     */
    'usedPercent': number;
    /**
     * 
     * @type {number}
     * @memberof RoleUsageMemory
     */
    'freePercent': number;
}
/**
 * 
 * @export
 * @interface SlackChannel
 */
export interface SlackChannel {
    /**
     * 
     * @type {string}
     * @memberof SlackChannel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SlackChannel
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof SlackChannel
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface TitlePrefix
 */
export interface TitlePrefix {
    /**
     * 
     * @type {string}
     * @memberof TitlePrefix
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface TryEmailRecipient400Response
 */
export interface TryEmailRecipient400Response {
    /**
     * 
     * @type {number}
     * @memberof TryEmailRecipient400Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof TryEmailRecipient400Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof TryEmailRecipient400Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface TryEmailRecipient500Response
 */
export interface TryEmailRecipient500Response {
    /**
     * 
     * @type {number}
     * @memberof TryEmailRecipient500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof TryEmailRecipient500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof TryEmailRecipient500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface TryEmailRecipientResponse
 */
export interface TryEmailRecipientResponse {
    /**
     * 
     * @type {number}
     * @memberof TryEmailRecipientResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof TryEmailRecipientResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof TryEmailRecipientResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface TryEmailSender
 */
export interface TryEmailSender {
    /**
     * 
     * @type {string}
     * @memberof TryEmailSender
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface TryEmailSender500Response
 */
export interface TryEmailSender500Response {
    /**
     * 
     * @type {number}
     * @memberof TryEmailSender500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof TryEmailSender500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof TryEmailSender500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface TryEmailSenderResponse
 */
export interface TryEmailSenderResponse {
    /**
     * 
     * @type {number}
     * @memberof TryEmailSenderResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof TryEmailSenderResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof TryEmailSenderResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface TrySlackChannel500Response
 */
export interface TrySlackChannel500Response {
    /**
     * 
     * @type {number}
     * @memberof TrySlackChannel500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof TrySlackChannel500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrySlackChannel500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface TrySlackChannelResponse
 */
export interface TrySlackChannelResponse {
    /**
     * 
     * @type {number}
     * @memberof TrySlackChannelResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof TrySlackChannelResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof TrySlackChannelResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface UpdateEmailRecipient500Response
 */
export interface UpdateEmailRecipient500Response {
    /**
     * 
     * @type {number}
     * @memberof UpdateEmailRecipient500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateEmailRecipient500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEmailRecipient500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTitlePrefix500Response
 */
export interface UpdateTitlePrefix500Response {
    /**
     * 
     * @type {number}
     * @memberof UpdateTitlePrefix500Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateTitlePrefix500Response
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTitlePrefix500Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTitlePrefixResponse
 */
export interface UpdateTitlePrefixResponse {
    /**
     * 
     * @type {number}
     * @memberof UpdateTitlePrefixResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateTitlePrefixResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTitlePrefixResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface UpdateTuningRequest
 */
export interface UpdateTuningRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTuningRequest
     */
    'value': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTuningRequest
     */
    'enabled': boolean;
    /**
     * 
     * @type {Array<UpdateTuningRequestRolesInner>}
     * @memberof UpdateTuningRequest
     */
    'roles': Array<UpdateTuningRequestRolesInner>;
}
/**
 * 
 * @export
 * @interface UpdateTuningRequestRolesInner
 */
export interface UpdateTuningRequestRolesInner {
    /**
     * 
     * @type {string}
     * @memberof UpdateTuningRequestRolesInner
     */
    'name': string;
    /**
     * 
     * @type {Array<UpdateTuningRequestRolesInnerHostsInner>}
     * @memberof UpdateTuningRequestRolesInner
     */
    'hosts': Array<UpdateTuningRequestRolesInnerHostsInner>;
}
/**
 * 
 * @export
 * @interface UpdateTuningRequestRolesInnerHostsInner
 */
export interface UpdateTuningRequestRolesInnerHostsInner {
    /**
     * 
     * @type {string}
     * @memberof UpdateTuningRequestRolesInnerHostsInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateTuningResponse
 */
export interface UpdateTuningResponse {
    /**
     * 
     * @type {number}
     * @memberof UpdateTuningResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateTuningResponse
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTuningResponse
     */
    'status': string;
}

/**
 * DataCentersApi - axios parameter creator
 * @export
 */
export const DataCentersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the data center info
         * @summary Retrieve the data center info
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataCenter: async (dataCenter: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getDataCenter', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the list of data centers
         * @summary Retrieve the list of data centers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataCenters: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/datacenters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataCentersApi - functional programming interface
 * @export
 */
export const DataCentersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataCentersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the data center info
         * @summary Retrieve the data center info
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataCenter(dataCenter: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDataCenterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataCenter(dataCenter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataCentersApi.getDataCenter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the list of data centers
         * @summary Retrieve the list of data centers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataCenters(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDataCentersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataCenters(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataCentersApi.getDataCenters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DataCentersApi - factory interface
 * @export
 */
export const DataCentersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataCentersApiFp(configuration)
    return {
        /**
         * Retrieve the data center info
         * @summary Retrieve the data center info
         * @param {DataCentersApiGetDataCenterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataCenter(requestParameters: DataCentersApiGetDataCenterRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetDataCenterResponse> {
            return localVarFp.getDataCenter(requestParameters.dataCenter, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the list of data centers
         * @summary Retrieve the list of data centers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataCenters(options?: RawAxiosRequestConfig): AxiosPromise<GetDataCentersResponse> {
            return localVarFp.getDataCenters(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDataCenter operation in DataCentersApi.
 * @export
 * @interface DataCentersApiGetDataCenterRequest
 */
export interface DataCentersApiGetDataCenterRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof DataCentersApiGetDataCenter
     */
    readonly dataCenter: string
}

/**
 * DataCentersApi - object-oriented interface
 * @export
 * @class DataCentersApi
 * @extends {BaseAPI}
 */
export class DataCentersApi extends BaseAPI {
    /**
     * Retrieve the data center info
     * @summary Retrieve the data center info
     * @param {DataCentersApiGetDataCenterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataCentersApi
     */
    public getDataCenter(requestParameters: DataCentersApiGetDataCenterRequest, options?: RawAxiosRequestConfig) {
        return DataCentersApiFp(this.configuration).getDataCenter(requestParameters.dataCenter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the list of data centers
     * @summary Retrieve the list of data centers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataCentersApi
     */
    public getDataCenters(options?: RawAxiosRequestConfig) {
        return DataCentersApiFp(this.configuration).getDataCenters(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the abstracted events
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetAbstractedEventsTypeEnum} type The type of event to query, the value can be only \&#39;system\&#39;, \&#39;host\&#39;, and \&#39;instance\&#39;.
         * @param {number} [limit] The limit of the abstracted events to return (default is 10).
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbstractedEvents: async (dataCenter: string, type: GetAbstractedEventsTypeEnum, limit?: number, watch?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getAbstractedEvents', 'dataCenter', dataCenter)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getAbstractedEvents', 'type', type)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/events/abstract`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (watch !== undefined) {
                localVarQueryParameter['watch'] = watch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the event filter conditions
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetEventFilterConditionsPastEnum} [past] The past time of the filter conditions to query, click \&#39;try it out\&#39; to see a few options, but can specify with the \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix for other time ranges.
         * @param {string} [start] The start time of the event to query, the value should be in RFC3339 format (default is 24 hours ago).
         * @param {string} [stop] The end time of the event to query, the value should be in RFC3339 format (default is now).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventFilterConditions: async (dataCenter: string, past?: GetEventFilterConditionsPastEnum, start?: string, stop?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getEventFilterConditions', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/events/filterConditions`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (past !== undefined) {
                localVarQueryParameter['past'] = past;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (stop !== undefined) {
                localVarQueryParameter['stop'] = stop;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the list of events
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetEventsTypeEnum} type The type of event to query, the value can be only \&#39;system\&#39;, \&#39;host\&#39;, and \&#39;instance\&#39;.
         * @param {string} [keyword] The keyword of the event to query.
         * @param {string} [id] The id of the event to query.
         * @param {string} [category] The category of the event to query.
         * @param {string} [severity] The severity of the event to query, the value can be only \&#39;Info\&#39;, \&#39;Warning\&#39;, and \&#39;Error\&#39;.
         * @param {string} [host] The host of the event to query.
         * @param {string} [instance] The instance of the event to query.
         * @param {string} [past] The past time of the event to query, use the unit of \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix to specify the time range.
         * @param {string} [start] The start time of the event to query, the value should be in RFC3339 format (default is 24 hours ago).
         * @param {string} [stop] The end time of the event to query, the value should be in RFC3339 format (default is now).
         * @param {number} [pageNum] The page number of the event chunking to fetch (default is 1).
         * @param {number} [pageSize] The size per page of the events to return (default is unlimit).
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (dataCenter: string, type: GetEventsTypeEnum, keyword?: string, id?: string, category?: string, severity?: string, host?: string, instance?: string, past?: string, start?: string, stop?: string, pageNum?: number, pageSize?: number, watch?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getEvents', 'dataCenter', dataCenter)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getEvents', 'type', type)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/events`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (severity !== undefined) {
                localVarQueryParameter['severity'] = severity;
            }

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (instance !== undefined) {
                localVarQueryParameter['instance'] = instance;
            }

            if (past !== undefined) {
                localVarQueryParameter['past'] = past;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (stop !== undefined) {
                localVarQueryParameter['stop'] = stop;
            }

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (watch !== undefined) {
                localVarQueryParameter['watch'] = watch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the ranked events
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetRankedEventsTypeEnum} type The type of event to query, the value can be only \&#39;system\&#39;, \&#39;host\&#39;, and \&#39;instance\&#39;.
         * @param {string} [category] The category of the event to query.
         * @param {string} [severity] The severity of the event to query, the value can be only \&#39;Info\&#39;, \&#39;Warning\&#39;, and \&#39;Error\&#39;.
         * @param {string} [host] The host of the event to query.
         * @param {string} [instance] The instance of the event to query.
         * @param {GetRankedEventsPastEnum} [past] The past time of the event rank to query, click \&#39;try it out\&#39; to see a few options, but can specify with the \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix for other time ranges.
         * @param {string} [start] The start time of the event to query, the value should be in RFC3339 format (default is 24 hours ago).
         * @param {string} [stop] The end time of the event to query, the value should be in RFC3339 format (default is now).
         * @param {number} [limit] The limit of the rank of event to return (default is 10).
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankedEvents: async (dataCenter: string, type: GetRankedEventsTypeEnum, category?: string, severity?: string, host?: string, instance?: string, past?: GetRankedEventsPastEnum, start?: string, stop?: string, limit?: number, watch?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getRankedEvents', 'dataCenter', dataCenter)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getRankedEvents', 'type', type)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/events/rank`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (severity !== undefined) {
                localVarQueryParameter['severity'] = severity;
            }

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (instance !== undefined) {
                localVarQueryParameter['instance'] = instance;
            }

            if (past !== undefined) {
                localVarQueryParameter['past'] = past;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (stop !== undefined) {
                localVarQueryParameter['stop'] = stop;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (watch !== undefined) {
                localVarQueryParameter['watch'] = watch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the abstracted events
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetAbstractedEventsTypeEnum} type The type of event to query, the value can be only \&#39;system\&#39;, \&#39;host\&#39;, and \&#39;instance\&#39;.
         * @param {number} [limit] The limit of the abstracted events to return (default is 10).
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAbstractedEvents(dataCenter: string, type: GetAbstractedEventsTypeEnum, limit?: number, watch?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAbstractedEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAbstractedEvents(dataCenter, type, limit, watch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getAbstractedEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the event filter conditions
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetEventFilterConditionsPastEnum} [past] The past time of the filter conditions to query, click \&#39;try it out\&#39; to see a few options, but can specify with the \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix for other time ranges.
         * @param {string} [start] The start time of the event to query, the value should be in RFC3339 format (default is 24 hours ago).
         * @param {string} [stop] The end time of the event to query, the value should be in RFC3339 format (default is now).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventFilterConditions(dataCenter: string, past?: GetEventFilterConditionsPastEnum, start?: string, stop?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventFilterConditionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventFilterConditions(dataCenter, past, start, stop, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getEventFilterConditions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the list of events
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetEventsTypeEnum} type The type of event to query, the value can be only \&#39;system\&#39;, \&#39;host\&#39;, and \&#39;instance\&#39;.
         * @param {string} [keyword] The keyword of the event to query.
         * @param {string} [id] The id of the event to query.
         * @param {string} [category] The category of the event to query.
         * @param {string} [severity] The severity of the event to query, the value can be only \&#39;Info\&#39;, \&#39;Warning\&#39;, and \&#39;Error\&#39;.
         * @param {string} [host] The host of the event to query.
         * @param {string} [instance] The instance of the event to query.
         * @param {string} [past] The past time of the event to query, use the unit of \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix to specify the time range.
         * @param {string} [start] The start time of the event to query, the value should be in RFC3339 format (default is 24 hours ago).
         * @param {string} [stop] The end time of the event to query, the value should be in RFC3339 format (default is now).
         * @param {number} [pageNum] The page number of the event chunking to fetch (default is 1).
         * @param {number} [pageSize] The size per page of the events to return (default is unlimit).
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(dataCenter: string, type: GetEventsTypeEnum, keyword?: string, id?: string, category?: string, severity?: string, host?: string, instance?: string, past?: string, start?: string, stop?: string, pageNum?: number, pageSize?: number, watch?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(dataCenter, type, keyword, id, category, severity, host, instance, past, start, stop, pageNum, pageSize, watch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the ranked events
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetRankedEventsTypeEnum} type The type of event to query, the value can be only \&#39;system\&#39;, \&#39;host\&#39;, and \&#39;instance\&#39;.
         * @param {string} [category] The category of the event to query.
         * @param {string} [severity] The severity of the event to query, the value can be only \&#39;Info\&#39;, \&#39;Warning\&#39;, and \&#39;Error\&#39;.
         * @param {string} [host] The host of the event to query.
         * @param {string} [instance] The instance of the event to query.
         * @param {GetRankedEventsPastEnum} [past] The past time of the event rank to query, click \&#39;try it out\&#39; to see a few options, but can specify with the \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix for other time ranges.
         * @param {string} [start] The start time of the event to query, the value should be in RFC3339 format (default is 24 hours ago).
         * @param {string} [stop] The end time of the event to query, the value should be in RFC3339 format (default is now).
         * @param {number} [limit] The limit of the rank of event to return (default is 10).
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankedEvents(dataCenter: string, type: GetRankedEventsTypeEnum, category?: string, severity?: string, host?: string, instance?: string, past?: GetRankedEventsPastEnum, start?: string, stop?: string, limit?: number, watch?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRankedEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRankedEvents(dataCenter, type, category, severity, host, instance, past, start, stop, limit, watch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getRankedEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the abstracted events
         * @param {EventsApiGetAbstractedEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbstractedEvents(requestParameters: EventsApiGetAbstractedEventsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetAbstractedEventsResponse> {
            return localVarFp.getAbstractedEvents(requestParameters.dataCenter, requestParameters.type, requestParameters.limit, requestParameters.watch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the event filter conditions
         * @param {EventsApiGetEventFilterConditionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventFilterConditions(requestParameters: EventsApiGetEventFilterConditionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetEventFilterConditionResponse> {
            return localVarFp.getEventFilterConditions(requestParameters.dataCenter, requestParameters.past, requestParameters.start, requestParameters.stop, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the list of events
         * @param {EventsApiGetEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(requestParameters: EventsApiGetEventsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetEventsResponse> {
            return localVarFp.getEvents(requestParameters.dataCenter, requestParameters.type, requestParameters.keyword, requestParameters.id, requestParameters.category, requestParameters.severity, requestParameters.host, requestParameters.instance, requestParameters.past, requestParameters.start, requestParameters.stop, requestParameters.pageNum, requestParameters.pageSize, requestParameters.watch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the ranked events
         * @param {EventsApiGetRankedEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankedEvents(requestParameters: EventsApiGetRankedEventsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetRankedEventsResponse> {
            return localVarFp.getRankedEvents(requestParameters.dataCenter, requestParameters.type, requestParameters.category, requestParameters.severity, requestParameters.host, requestParameters.instance, requestParameters.past, requestParameters.start, requestParameters.stop, requestParameters.limit, requestParameters.watch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAbstractedEvents operation in EventsApi.
 * @export
 * @interface EventsApiGetAbstractedEventsRequest
 */
export interface EventsApiGetAbstractedEventsRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof EventsApiGetAbstractedEvents
     */
    readonly dataCenter: string

    /**
     * The type of event to query, the value can be only \&#39;system\&#39;, \&#39;host\&#39;, and \&#39;instance\&#39;.
     * @type {'system' | 'host' | 'instance'}
     * @memberof EventsApiGetAbstractedEvents
     */
    readonly type: GetAbstractedEventsTypeEnum

    /**
     * The limit of the abstracted events to return (default is 10).
     * @type {number}
     * @memberof EventsApiGetAbstractedEvents
     */
    readonly limit?: number

    /**
     * The toggle to enable http chunked transfer for continuous server push.
     * @type {boolean}
     * @memberof EventsApiGetAbstractedEvents
     */
    readonly watch?: boolean
}

/**
 * Request parameters for getEventFilterConditions operation in EventsApi.
 * @export
 * @interface EventsApiGetEventFilterConditionsRequest
 */
export interface EventsApiGetEventFilterConditionsRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof EventsApiGetEventFilterConditions
     */
    readonly dataCenter: string

    /**
     * The past time of the filter conditions to query, click \&#39;try it out\&#39; to see a few options, but can specify with the \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix for other time ranges.
     * @type {'1h' | '24h' | '7d' | '14d'}
     * @memberof EventsApiGetEventFilterConditions
     */
    readonly past?: GetEventFilterConditionsPastEnum

    /**
     * The start time of the event to query, the value should be in RFC3339 format (default is 24 hours ago).
     * @type {string}
     * @memberof EventsApiGetEventFilterConditions
     */
    readonly start?: string

    /**
     * The end time of the event to query, the value should be in RFC3339 format (default is now).
     * @type {string}
     * @memberof EventsApiGetEventFilterConditions
     */
    readonly stop?: string
}

/**
 * Request parameters for getEvents operation in EventsApi.
 * @export
 * @interface EventsApiGetEventsRequest
 */
export interface EventsApiGetEventsRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof EventsApiGetEvents
     */
    readonly dataCenter: string

    /**
     * The type of event to query, the value can be only \&#39;system\&#39;, \&#39;host\&#39;, and \&#39;instance\&#39;.
     * @type {'system' | 'host' | 'instance'}
     * @memberof EventsApiGetEvents
     */
    readonly type: GetEventsTypeEnum

    /**
     * The keyword of the event to query.
     * @type {string}
     * @memberof EventsApiGetEvents
     */
    readonly keyword?: string

    /**
     * The id of the event to query.
     * @type {string}
     * @memberof EventsApiGetEvents
     */
    readonly id?: string

    /**
     * The category of the event to query.
     * @type {string}
     * @memberof EventsApiGetEvents
     */
    readonly category?: string

    /**
     * The severity of the event to query, the value can be only \&#39;Info\&#39;, \&#39;Warning\&#39;, and \&#39;Error\&#39;.
     * @type {string}
     * @memberof EventsApiGetEvents
     */
    readonly severity?: string

    /**
     * The host of the event to query.
     * @type {string}
     * @memberof EventsApiGetEvents
     */
    readonly host?: string

    /**
     * The instance of the event to query.
     * @type {string}
     * @memberof EventsApiGetEvents
     */
    readonly instance?: string

    /**
     * The past time of the event to query, use the unit of \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix to specify the time range.
     * @type {string}
     * @memberof EventsApiGetEvents
     */
    readonly past?: string

    /**
     * The start time of the event to query, the value should be in RFC3339 format (default is 24 hours ago).
     * @type {string}
     * @memberof EventsApiGetEvents
     */
    readonly start?: string

    /**
     * The end time of the event to query, the value should be in RFC3339 format (default is now).
     * @type {string}
     * @memberof EventsApiGetEvents
     */
    readonly stop?: string

    /**
     * The page number of the event chunking to fetch (default is 1).
     * @type {number}
     * @memberof EventsApiGetEvents
     */
    readonly pageNum?: number

    /**
     * The size per page of the events to return (default is unlimit).
     * @type {number}
     * @memberof EventsApiGetEvents
     */
    readonly pageSize?: number

    /**
     * The toggle to enable http chunked transfer for continuous server push.
     * @type {boolean}
     * @memberof EventsApiGetEvents
     */
    readonly watch?: boolean
}

/**
 * Request parameters for getRankedEvents operation in EventsApi.
 * @export
 * @interface EventsApiGetRankedEventsRequest
 */
export interface EventsApiGetRankedEventsRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof EventsApiGetRankedEvents
     */
    readonly dataCenter: string

    /**
     * The type of event to query, the value can be only \&#39;system\&#39;, \&#39;host\&#39;, and \&#39;instance\&#39;.
     * @type {'system' | 'host' | 'instance'}
     * @memberof EventsApiGetRankedEvents
     */
    readonly type: GetRankedEventsTypeEnum

    /**
     * The category of the event to query.
     * @type {string}
     * @memberof EventsApiGetRankedEvents
     */
    readonly category?: string

    /**
     * The severity of the event to query, the value can be only \&#39;Info\&#39;, \&#39;Warning\&#39;, and \&#39;Error\&#39;.
     * @type {string}
     * @memberof EventsApiGetRankedEvents
     */
    readonly severity?: string

    /**
     * The host of the event to query.
     * @type {string}
     * @memberof EventsApiGetRankedEvents
     */
    readonly host?: string

    /**
     * The instance of the event to query.
     * @type {string}
     * @memberof EventsApiGetRankedEvents
     */
    readonly instance?: string

    /**
     * The past time of the event rank to query, click \&#39;try it out\&#39; to see a few options, but can specify with the \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix for other time ranges.
     * @type {'1h' | '24h' | '7d' | '14d'}
     * @memberof EventsApiGetRankedEvents
     */
    readonly past?: GetRankedEventsPastEnum

    /**
     * The start time of the event to query, the value should be in RFC3339 format (default is 24 hours ago).
     * @type {string}
     * @memberof EventsApiGetRankedEvents
     */
    readonly start?: string

    /**
     * The end time of the event to query, the value should be in RFC3339 format (default is now).
     * @type {string}
     * @memberof EventsApiGetRankedEvents
     */
    readonly stop?: string

    /**
     * The limit of the rank of event to return (default is 10).
     * @type {number}
     * @memberof EventsApiGetRankedEvents
     */
    readonly limit?: number

    /**
     * The toggle to enable http chunked transfer for continuous server push.
     * @type {boolean}
     * @memberof EventsApiGetRankedEvents
     */
    readonly watch?: boolean
}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the abstracted events
     * @param {EventsApiGetAbstractedEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getAbstractedEvents(requestParameters: EventsApiGetAbstractedEventsRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getAbstractedEvents(requestParameters.dataCenter, requestParameters.type, requestParameters.limit, requestParameters.watch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the event filter conditions
     * @param {EventsApiGetEventFilterConditionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventFilterConditions(requestParameters: EventsApiGetEventFilterConditionsRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventFilterConditions(requestParameters.dataCenter, requestParameters.past, requestParameters.start, requestParameters.stop, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the list of events
     * @param {EventsApiGetEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvents(requestParameters: EventsApiGetEventsRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEvents(requestParameters.dataCenter, requestParameters.type, requestParameters.keyword, requestParameters.id, requestParameters.category, requestParameters.severity, requestParameters.host, requestParameters.instance, requestParameters.past, requestParameters.start, requestParameters.stop, requestParameters.pageNum, requestParameters.pageSize, requestParameters.watch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the ranked events
     * @param {EventsApiGetRankedEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getRankedEvents(requestParameters: EventsApiGetRankedEventsRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getRankedEvents(requestParameters.dataCenter, requestParameters.type, requestParameters.category, requestParameters.severity, requestParameters.host, requestParameters.instance, requestParameters.past, requestParameters.start, requestParameters.stop, requestParameters.limit, requestParameters.watch, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAbstractedEventsTypeEnum = {
    System: 'system',
    Host: 'host',
    Instance: 'instance'
} as const;
export type GetAbstractedEventsTypeEnum = typeof GetAbstractedEventsTypeEnum[keyof typeof GetAbstractedEventsTypeEnum];
/**
 * @export
 */
export const GetEventFilterConditionsPastEnum = {
    _1h: '1h',
    _24h: '24h',
    _7d: '7d',
    _14d: '14d'
} as const;
export type GetEventFilterConditionsPastEnum = typeof GetEventFilterConditionsPastEnum[keyof typeof GetEventFilterConditionsPastEnum];
/**
 * @export
 */
export const GetEventsTypeEnum = {
    System: 'system',
    Host: 'host',
    Instance: 'instance'
} as const;
export type GetEventsTypeEnum = typeof GetEventsTypeEnum[keyof typeof GetEventsTypeEnum];
/**
 * @export
 */
export const GetRankedEventsTypeEnum = {
    System: 'system',
    Host: 'host',
    Instance: 'instance'
} as const;
export type GetRankedEventsTypeEnum = typeof GetRankedEventsTypeEnum[keyof typeof GetRankedEventsTypeEnum];
/**
 * @export
 */
export const GetRankedEventsPastEnum = {
    _1h: '1h',
    _24h: '24h',
    _7d: '7d',
    _14d: '14d'
} as const;
export type GetRankedEventsPastEnum = typeof GetRankedEventsPastEnum[keyof typeof GetRankedEventsPastEnum];


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the health history of module
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetHealthHistoryServiceTypeEnum} serviceType The name of the service to retrieve health history. use GET /api/v1/datacenters/{dataCenter}/services to get the service list and their modules.
         * @param {GetHealthHistoryModuleTypeEnum} moduleType The name of the module to retrieve health history. use GET /api/v1/datacenters/{dataCenter}/services/{serviceType} to get the module list.
         * @param {GetHealthHistoryPastEnum} [past] The past time of the health history to query, click \&#39;try it out\&#39; to see a few options, but can specify with the \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix for other time ranges.
         * @param {string} [start] The start time of the health history to query, the value should be in RFC3339 format (default is 24 hours ago).
         * @param {string} [stop] The end time of the health history to query, the value should be in RFC3339 format (default is now).
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthHistory: async (dataCenter: string, serviceType: GetHealthHistoryServiceTypeEnum, moduleType: GetHealthHistoryModuleTypeEnum, past?: GetHealthHistoryPastEnum, start?: string, stop?: string, watch?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getHealthHistory', 'dataCenter', dataCenter)
            // verify required parameter 'serviceType' is not null or undefined
            assertParamExists('getHealthHistory', 'serviceType', serviceType)
            // verify required parameter 'moduleType' is not null or undefined
            assertParamExists('getHealthHistory', 'moduleType', moduleType)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/healths/services/{serviceType}/modules/{moduleType}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"serviceType"}}`, encodeURIComponent(String(serviceType)))
                .replace(`{${"moduleType"}}`, encodeURIComponent(String(moduleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (past !== undefined) {
                localVarQueryParameter['past'] = past;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (stop !== undefined) {
                localVarQueryParameter['stop'] = stop;
            }

            if (watch !== undefined) {
                localVarQueryParameter['watch'] = watch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the overall health status of all modules
         * @param {string} dataCenter The name of the data center to operate
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealths: async (dataCenter: string, watch?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getHealths', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/healths`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (watch !== undefined) {
                localVarQueryParameter['watch'] = watch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the all modules health status from a service
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetServiceHealthHistoryServiceTypeEnum} serviceType The name of the service to retrieve health history. use GET /api/v1/datacenters/{dataCenter}/services to get the service list and their modules.
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {string} [start] The start time of the health history to query, the value should be in RFC3339 format (default is 24 hours ago).
         * @param {string} [stop] The end time of the health history to query, the value should be in RFC3339 format (default is now).
         * @param {GetServiceHealthHistoryPastEnum} [past] The past time of the health history to query, click \&#39;try it out\&#39; to see a few options, but can specify with the \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix for other time ranges.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceHealthHistory: async (dataCenter: string, serviceType: GetServiceHealthHistoryServiceTypeEnum, watch?: boolean, start?: string, stop?: string, past?: GetServiceHealthHistoryPastEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getServiceHealthHistory', 'dataCenter', dataCenter)
            // verify required parameter 'serviceType' is not null or undefined
            assertParamExists('getServiceHealthHistory', 'serviceType', serviceType)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/healths/services/{serviceType}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"serviceType"}}`, encodeURIComponent(String(serviceType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (watch !== undefined) {
                localVarQueryParameter['watch'] = watch;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (stop !== undefined) {
                localVarQueryParameter['stop'] = stop;
            }

            if (past !== undefined) {
                localVarQueryParameter['past'] = past;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Repair the health for all modules
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repairAllModulesHealth: async (dataCenter: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('repairAllModulesHealth', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/healths`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Repair the unhealthy module
         * @param {string} dataCenter The name of the data center to operate
         * @param {RepairModuleHealthServiceTypeEnum} serviceType The name of the service which cover the module you tend to repair. use GET /api/v1/datacenters/{dataCenter}/services to get the service list and their modules.
         * @param {RepairModuleHealthModuleTypeEnum} moduleType The name of the module to repair. use GET /api/v1/datacenters/{dataCenter}/services/{serviceType} to get the module list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repairModuleHealth: async (dataCenter: string, serviceType: RepairModuleHealthServiceTypeEnum, moduleType: RepairModuleHealthModuleTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('repairModuleHealth', 'dataCenter', dataCenter)
            // verify required parameter 'serviceType' is not null or undefined
            assertParamExists('repairModuleHealth', 'serviceType', serviceType)
            // verify required parameter 'moduleType' is not null or undefined
            assertParamExists('repairModuleHealth', 'moduleType', moduleType)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/healths/services/{serviceType}/modules/{moduleType}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"serviceType"}}`, encodeURIComponent(String(serviceType)))
                .replace(`{${"moduleType"}}`, encodeURIComponent(String(moduleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the health history of module
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetHealthHistoryServiceTypeEnum} serviceType The name of the service to retrieve health history. use GET /api/v1/datacenters/{dataCenter}/services to get the service list and their modules.
         * @param {GetHealthHistoryModuleTypeEnum} moduleType The name of the module to retrieve health history. use GET /api/v1/datacenters/{dataCenter}/services/{serviceType} to get the module list.
         * @param {GetHealthHistoryPastEnum} [past] The past time of the health history to query, click \&#39;try it out\&#39; to see a few options, but can specify with the \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix for other time ranges.
         * @param {string} [start] The start time of the health history to query, the value should be in RFC3339 format (default is 24 hours ago).
         * @param {string} [stop] The end time of the health history to query, the value should be in RFC3339 format (default is now).
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealthHistory(dataCenter: string, serviceType: GetHealthHistoryServiceTypeEnum, moduleType: GetHealthHistoryModuleTypeEnum, past?: GetHealthHistoryPastEnum, start?: string, stop?: string, watch?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetModuleHealthHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealthHistory(dataCenter, serviceType, moduleType, past, start, stop, watch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.getHealthHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the overall health status of all modules
         * @param {string} dataCenter The name of the data center to operate
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealths(dataCenter: string, watch?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHealthsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealths(dataCenter, watch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.getHealths']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the all modules health status from a service
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetServiceHealthHistoryServiceTypeEnum} serviceType The name of the service to retrieve health history. use GET /api/v1/datacenters/{dataCenter}/services to get the service list and their modules.
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {string} [start] The start time of the health history to query, the value should be in RFC3339 format (default is 24 hours ago).
         * @param {string} [stop] The end time of the health history to query, the value should be in RFC3339 format (default is now).
         * @param {GetServiceHealthHistoryPastEnum} [past] The past time of the health history to query, click \&#39;try it out\&#39; to see a few options, but can specify with the \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix for other time ranges.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceHealthHistory(dataCenter: string, serviceType: GetServiceHealthHistoryServiceTypeEnum, watch?: boolean, start?: string, stop?: string, past?: GetServiceHealthHistoryPastEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetServiceHealthHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceHealthHistory(dataCenter, serviceType, watch, start, stop, past, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.getServiceHealthHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Repair the health for all modules
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repairAllModulesHealth(dataCenter: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PatchRepairResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repairAllModulesHealth(dataCenter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.repairAllModulesHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Repair the unhealthy module
         * @param {string} dataCenter The name of the data center to operate
         * @param {RepairModuleHealthServiceTypeEnum} serviceType The name of the service which cover the module you tend to repair. use GET /api/v1/datacenters/{dataCenter}/services to get the service list and their modules.
         * @param {RepairModuleHealthModuleTypeEnum} moduleType The name of the module to repair. use GET /api/v1/datacenters/{dataCenter}/services/{serviceType} to get the module list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repairModuleHealth(dataCenter: string, serviceType: RepairModuleHealthServiceTypeEnum, moduleType: RepairModuleHealthModuleTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PatchModuleRepairResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repairModuleHealth(dataCenter, serviceType, moduleType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.repairModuleHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the health history of module
         * @param {HealthApiGetHealthHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthHistory(requestParameters: HealthApiGetHealthHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetModuleHealthHistoryResponse> {
            return localVarFp.getHealthHistory(requestParameters.dataCenter, requestParameters.serviceType, requestParameters.moduleType, requestParameters.past, requestParameters.start, requestParameters.stop, requestParameters.watch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the overall health status of all modules
         * @param {HealthApiGetHealthsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealths(requestParameters: HealthApiGetHealthsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetHealthsResponse> {
            return localVarFp.getHealths(requestParameters.dataCenter, requestParameters.watch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the all modules health status from a service
         * @param {HealthApiGetServiceHealthHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceHealthHistory(requestParameters: HealthApiGetServiceHealthHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetServiceHealthHistoryResponse> {
            return localVarFp.getServiceHealthHistory(requestParameters.dataCenter, requestParameters.serviceType, requestParameters.watch, requestParameters.start, requestParameters.stop, requestParameters.past, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Repair the health for all modules
         * @param {HealthApiRepairAllModulesHealthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repairAllModulesHealth(requestParameters: HealthApiRepairAllModulesHealthRequest, options?: RawAxiosRequestConfig): AxiosPromise<PatchRepairResponse> {
            return localVarFp.repairAllModulesHealth(requestParameters.dataCenter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Repair the unhealthy module
         * @param {HealthApiRepairModuleHealthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repairModuleHealth(requestParameters: HealthApiRepairModuleHealthRequest, options?: RawAxiosRequestConfig): AxiosPromise<PatchModuleRepairResponse> {
            return localVarFp.repairModuleHealth(requestParameters.dataCenter, requestParameters.serviceType, requestParameters.moduleType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getHealthHistory operation in HealthApi.
 * @export
 * @interface HealthApiGetHealthHistoryRequest
 */
export interface HealthApiGetHealthHistoryRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof HealthApiGetHealthHistory
     */
    readonly dataCenter: string

    /**
     * The name of the service to retrieve health history. use GET /api/v1/datacenters/{dataCenter}/services to get the service list and their modules.
     * @type {'clusterLink' | 'clusterSys' | 'clusterSettings' | 'haCluster' | 'msgQueue' | 'iaasDb' | 'virtualIp' | 'storage' | 'apiService' | 'singleSignOn' | 'network' | 'compute' | 'bareMetal' | 'image' | 'blockStor' | 'fileStor' | 'objectStor' | 'orchestration' | 'lbaas' | 'dnsaas' | 'k8saas' | 'instanceHa' | 'businessLogic' | 'dataPipe' | 'metrics' | 'logAnalytics' | 'notifications'}
     * @memberof HealthApiGetHealthHistory
     */
    readonly serviceType: GetHealthHistoryServiceTypeEnum

    /**
     * The name of the module to retrieve health history. use GET /api/v1/datacenters/{dataCenter}/services/{serviceType} to get the module list.
     * @type {'link' | 'clock' | 'dns' | 'bootstrap' | 'license' | 'etcd' | 'nodelist' | 'hacluster' | 'rabbitmq' | 'mysql' | 'mongodb' | 'vip' | 'haproxy_ha' | 'ceph' | 'ceph_mon' | 'ceph_osd' | 'ceph_rgw' | 'ceph_mds' | 'ceph_mgr' | 'rbd_target' | 'haproxy' | 'httpd' | 'skyline' | 'lim' | 'memcache' | 'k3s' | 'keycloak' | 'neutron' | 'nova' | 'cyborg' | 'ironic' | 'glance' | 'cinder' | 'manila' | 'swift' | 'heat' | 'octavia' | 'designate' | 'rancher' | 'masakari' | 'zookeeper' | 'kafka' | 'monasca' | 'telegraf' | 'grafana' | 'filebeat' | 'auditbeat' | 'logstash' | 'opensearch' | 'opensearch-dashboards' | 'influxdb' | 'kapacitor'}
     * @memberof HealthApiGetHealthHistory
     */
    readonly moduleType: GetHealthHistoryModuleTypeEnum

    /**
     * The past time of the health history to query, click \&#39;try it out\&#39; to see a few options, but can specify with the \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix for other time ranges.
     * @type {'1h' | '24h' | '7d' | '14d' | '30d'}
     * @memberof HealthApiGetHealthHistory
     */
    readonly past?: GetHealthHistoryPastEnum

    /**
     * The start time of the health history to query, the value should be in RFC3339 format (default is 24 hours ago).
     * @type {string}
     * @memberof HealthApiGetHealthHistory
     */
    readonly start?: string

    /**
     * The end time of the health history to query, the value should be in RFC3339 format (default is now).
     * @type {string}
     * @memberof HealthApiGetHealthHistory
     */
    readonly stop?: string

    /**
     * The toggle to enable http chunked transfer for continuous server push.
     * @type {boolean}
     * @memberof HealthApiGetHealthHistory
     */
    readonly watch?: boolean
}

/**
 * Request parameters for getHealths operation in HealthApi.
 * @export
 * @interface HealthApiGetHealthsRequest
 */
export interface HealthApiGetHealthsRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof HealthApiGetHealths
     */
    readonly dataCenter: string

    /**
     * The toggle to enable http chunked transfer for continuous server push.
     * @type {boolean}
     * @memberof HealthApiGetHealths
     */
    readonly watch?: boolean
}

/**
 * Request parameters for getServiceHealthHistory operation in HealthApi.
 * @export
 * @interface HealthApiGetServiceHealthHistoryRequest
 */
export interface HealthApiGetServiceHealthHistoryRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof HealthApiGetServiceHealthHistory
     */
    readonly dataCenter: string

    /**
     * The name of the service to retrieve health history. use GET /api/v1/datacenters/{dataCenter}/services to get the service list and their modules.
     * @type {'clusterLink' | 'clusterSys' | 'clusterSettings' | 'haCluster' | 'msgQueue' | 'iaasDb' | 'virtualIp' | 'storage' | 'apiService' | 'singleSignOn' | 'network' | 'compute' | 'bareMetal' | 'image' | 'blockStor' | 'fileStor' | 'objectStor' | 'orchestration' | 'lbaas' | 'dnsaas' | 'k8saas' | 'instanceHa' | 'businessLogic' | 'dataPipe' | 'metrics' | 'logAnalytics' | 'notifications'}
     * @memberof HealthApiGetServiceHealthHistory
     */
    readonly serviceType: GetServiceHealthHistoryServiceTypeEnum

    /**
     * The toggle to enable http chunked transfer for continuous server push.
     * @type {boolean}
     * @memberof HealthApiGetServiceHealthHistory
     */
    readonly watch?: boolean

    /**
     * The start time of the health history to query, the value should be in RFC3339 format (default is 24 hours ago).
     * @type {string}
     * @memberof HealthApiGetServiceHealthHistory
     */
    readonly start?: string

    /**
     * The end time of the health history to query, the value should be in RFC3339 format (default is now).
     * @type {string}
     * @memberof HealthApiGetServiceHealthHistory
     */
    readonly stop?: string

    /**
     * The past time of the health history to query, click \&#39;try it out\&#39; to see a few options, but can specify with the \&#39;s\&#39;(second), \&#39;m\&#39;(minute), \&#39;h\&#39;(hour), and \&#39;d\&#39;(day) suffix for other time ranges.
     * @type {'1h' | '24h' | '7d' | '14d' | '30d'}
     * @memberof HealthApiGetServiceHealthHistory
     */
    readonly past?: GetServiceHealthHistoryPastEnum
}

/**
 * Request parameters for repairAllModulesHealth operation in HealthApi.
 * @export
 * @interface HealthApiRepairAllModulesHealthRequest
 */
export interface HealthApiRepairAllModulesHealthRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof HealthApiRepairAllModulesHealth
     */
    readonly dataCenter: string
}

/**
 * Request parameters for repairModuleHealth operation in HealthApi.
 * @export
 * @interface HealthApiRepairModuleHealthRequest
 */
export interface HealthApiRepairModuleHealthRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof HealthApiRepairModuleHealth
     */
    readonly dataCenter: string

    /**
     * The name of the service which cover the module you tend to repair. use GET /api/v1/datacenters/{dataCenter}/services to get the service list and their modules.
     * @type {'clusterLink' | 'clusterSys' | 'clusterSettings' | 'haCluster' | 'msgQueue' | 'iaasDb' | 'virtualIp' | 'storage' | 'apiService' | 'singleSignOn' | 'network' | 'compute' | 'bareMetal' | 'image' | 'blockStor' | 'fileStor' | 'objectStor' | 'orchestration' | 'lbaas' | 'dnsaas' | 'k8saas' | 'instanceHa' | 'businessLogic' | 'dataPipe' | 'metrics' | 'logAnalytics' | 'notifications'}
     * @memberof HealthApiRepairModuleHealth
     */
    readonly serviceType: RepairModuleHealthServiceTypeEnum

    /**
     * The name of the module to repair. use GET /api/v1/datacenters/{dataCenter}/services/{serviceType} to get the module list.
     * @type {'link' | 'clock' | 'dns' | 'bootstrap' | 'license' | 'etcd' | 'nodelist' | 'hacluster' | 'rabbitmq' | 'mysql' | 'mongodb' | 'vip' | 'haproxy_ha' | 'ceph' | 'ceph_mon' | 'ceph_osd' | 'ceph_rgw' | 'ceph_mds' | 'ceph_mgr' | 'rbd_target' | 'haproxy' | 'httpd' | 'skyline' | 'lim' | 'memcache' | 'k3s' | 'keycloak' | 'neutron' | 'nova' | 'cyborg' | 'ironic' | 'glance' | 'cinder' | 'manila' | 'swift' | 'heat' | 'octavia' | 'designate' | 'rancher' | 'masakari' | 'zookeeper' | 'kafka' | 'monasca' | 'telegraf' | 'grafana' | 'filebeat' | 'auditbeat' | 'logstash' | 'opensearch' | 'opensearch-dashboards' | 'influxdb' | 'kapacitor'}
     * @memberof HealthApiRepairModuleHealth
     */
    readonly moduleType: RepairModuleHealthModuleTypeEnum
}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the health history of module
     * @param {HealthApiGetHealthHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getHealthHistory(requestParameters: HealthApiGetHealthHistoryRequest, options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).getHealthHistory(requestParameters.dataCenter, requestParameters.serviceType, requestParameters.moduleType, requestParameters.past, requestParameters.start, requestParameters.stop, requestParameters.watch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the overall health status of all modules
     * @param {HealthApiGetHealthsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getHealths(requestParameters: HealthApiGetHealthsRequest, options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).getHealths(requestParameters.dataCenter, requestParameters.watch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the all modules health status from a service
     * @param {HealthApiGetServiceHealthHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getServiceHealthHistory(requestParameters: HealthApiGetServiceHealthHistoryRequest, options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).getServiceHealthHistory(requestParameters.dataCenter, requestParameters.serviceType, requestParameters.watch, requestParameters.start, requestParameters.stop, requestParameters.past, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Repair the health for all modules
     * @param {HealthApiRepairAllModulesHealthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public repairAllModulesHealth(requestParameters: HealthApiRepairAllModulesHealthRequest, options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).repairAllModulesHealth(requestParameters.dataCenter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Repair the unhealthy module
     * @param {HealthApiRepairModuleHealthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public repairModuleHealth(requestParameters: HealthApiRepairModuleHealthRequest, options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).repairModuleHealth(requestParameters.dataCenter, requestParameters.serviceType, requestParameters.moduleType, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetHealthHistoryServiceTypeEnum = {
    ClusterLink: 'clusterLink',
    ClusterSys: 'clusterSys',
    ClusterSettings: 'clusterSettings',
    HaCluster: 'haCluster',
    MsgQueue: 'msgQueue',
    IaasDb: 'iaasDb',
    VirtualIp: 'virtualIp',
    Storage: 'storage',
    ApiService: 'apiService',
    SingleSignOn: 'singleSignOn',
    Network: 'network',
    Compute: 'compute',
    BareMetal: 'bareMetal',
    Image: 'image',
    BlockStor: 'blockStor',
    FileStor: 'fileStor',
    ObjectStor: 'objectStor',
    Orchestration: 'orchestration',
    Lbaas: 'lbaas',
    Dnsaas: 'dnsaas',
    K8saas: 'k8saas',
    InstanceHa: 'instanceHa',
    BusinessLogic: 'businessLogic',
    DataPipe: 'dataPipe',
    Metrics: 'metrics',
    LogAnalytics: 'logAnalytics',
    Notifications: 'notifications'
} as const;
export type GetHealthHistoryServiceTypeEnum = typeof GetHealthHistoryServiceTypeEnum[keyof typeof GetHealthHistoryServiceTypeEnum];
/**
 * @export
 */
export const GetHealthHistoryModuleTypeEnum = {
    Link: 'link',
    Clock: 'clock',
    Dns: 'dns',
    Bootstrap: 'bootstrap',
    License: 'license',
    Etcd: 'etcd',
    Nodelist: 'nodelist',
    Hacluster: 'hacluster',
    Rabbitmq: 'rabbitmq',
    Mysql: 'mysql',
    Mongodb: 'mongodb',
    Vip: 'vip',
    HaproxyHa: 'haproxy_ha',
    Ceph: 'ceph',
    CephMon: 'ceph_mon',
    CephOsd: 'ceph_osd',
    CephRgw: 'ceph_rgw',
    CephMds: 'ceph_mds',
    CephMgr: 'ceph_mgr',
    RbdTarget: 'rbd_target',
    Haproxy: 'haproxy',
    Httpd: 'httpd',
    Skyline: 'skyline',
    Lim: 'lim',
    Memcache: 'memcache',
    K3s: 'k3s',
    Keycloak: 'keycloak',
    Neutron: 'neutron',
    Nova: 'nova',
    Cyborg: 'cyborg',
    Ironic: 'ironic',
    Glance: 'glance',
    Cinder: 'cinder',
    Manila: 'manila',
    Swift: 'swift',
    Heat: 'heat',
    Octavia: 'octavia',
    Designate: 'designate',
    Rancher: 'rancher',
    Masakari: 'masakari',
    Zookeeper: 'zookeeper',
    Kafka: 'kafka',
    Monasca: 'monasca',
    Telegraf: 'telegraf',
    Grafana: 'grafana',
    Filebeat: 'filebeat',
    Auditbeat: 'auditbeat',
    Logstash: 'logstash',
    Opensearch: 'opensearch',
    OpensearchDashboards: 'opensearch-dashboards',
    Influxdb: 'influxdb',
    Kapacitor: 'kapacitor'
} as const;
export type GetHealthHistoryModuleTypeEnum = typeof GetHealthHistoryModuleTypeEnum[keyof typeof GetHealthHistoryModuleTypeEnum];
/**
 * @export
 */
export const GetHealthHistoryPastEnum = {
    _1h: '1h',
    _24h: '24h',
    _7d: '7d',
    _14d: '14d',
    _30d: '30d'
} as const;
export type GetHealthHistoryPastEnum = typeof GetHealthHistoryPastEnum[keyof typeof GetHealthHistoryPastEnum];
/**
 * @export
 */
export const GetServiceHealthHistoryServiceTypeEnum = {
    ClusterLink: 'clusterLink',
    ClusterSys: 'clusterSys',
    ClusterSettings: 'clusterSettings',
    HaCluster: 'haCluster',
    MsgQueue: 'msgQueue',
    IaasDb: 'iaasDb',
    VirtualIp: 'virtualIp',
    Storage: 'storage',
    ApiService: 'apiService',
    SingleSignOn: 'singleSignOn',
    Network: 'network',
    Compute: 'compute',
    BareMetal: 'bareMetal',
    Image: 'image',
    BlockStor: 'blockStor',
    FileStor: 'fileStor',
    ObjectStor: 'objectStor',
    Orchestration: 'orchestration',
    Lbaas: 'lbaas',
    Dnsaas: 'dnsaas',
    K8saas: 'k8saas',
    InstanceHa: 'instanceHa',
    BusinessLogic: 'businessLogic',
    DataPipe: 'dataPipe',
    Metrics: 'metrics',
    LogAnalytics: 'logAnalytics',
    Notifications: 'notifications'
} as const;
export type GetServiceHealthHistoryServiceTypeEnum = typeof GetServiceHealthHistoryServiceTypeEnum[keyof typeof GetServiceHealthHistoryServiceTypeEnum];
/**
 * @export
 */
export const GetServiceHealthHistoryPastEnum = {
    _1h: '1h',
    _24h: '24h',
    _7d: '7d',
    _14d: '14d',
    _30d: '30d'
} as const;
export type GetServiceHealthHistoryPastEnum = typeof GetServiceHealthHistoryPastEnum[keyof typeof GetServiceHealthHistoryPastEnum];
/**
 * @export
 */
export const RepairModuleHealthServiceTypeEnum = {
    ClusterLink: 'clusterLink',
    ClusterSys: 'clusterSys',
    ClusterSettings: 'clusterSettings',
    HaCluster: 'haCluster',
    MsgQueue: 'msgQueue',
    IaasDb: 'iaasDb',
    VirtualIp: 'virtualIp',
    Storage: 'storage',
    ApiService: 'apiService',
    SingleSignOn: 'singleSignOn',
    Network: 'network',
    Compute: 'compute',
    BareMetal: 'bareMetal',
    Image: 'image',
    BlockStor: 'blockStor',
    FileStor: 'fileStor',
    ObjectStor: 'objectStor',
    Orchestration: 'orchestration',
    Lbaas: 'lbaas',
    Dnsaas: 'dnsaas',
    K8saas: 'k8saas',
    InstanceHa: 'instanceHa',
    BusinessLogic: 'businessLogic',
    DataPipe: 'dataPipe',
    Metrics: 'metrics',
    LogAnalytics: 'logAnalytics',
    Notifications: 'notifications'
} as const;
export type RepairModuleHealthServiceTypeEnum = typeof RepairModuleHealthServiceTypeEnum[keyof typeof RepairModuleHealthServiceTypeEnum];
/**
 * @export
 */
export const RepairModuleHealthModuleTypeEnum = {
    Link: 'link',
    Clock: 'clock',
    Dns: 'dns',
    Bootstrap: 'bootstrap',
    License: 'license',
    Etcd: 'etcd',
    Nodelist: 'nodelist',
    Hacluster: 'hacluster',
    Rabbitmq: 'rabbitmq',
    Mysql: 'mysql',
    Mongodb: 'mongodb',
    Vip: 'vip',
    HaproxyHa: 'haproxy_ha',
    Ceph: 'ceph',
    CephMon: 'ceph_mon',
    CephOsd: 'ceph_osd',
    CephRgw: 'ceph_rgw',
    CephMds: 'ceph_mds',
    CephMgr: 'ceph_mgr',
    RbdTarget: 'rbd_target',
    Haproxy: 'haproxy',
    Httpd: 'httpd',
    Skyline: 'skyline',
    Lim: 'lim',
    Memcache: 'memcache',
    K3s: 'k3s',
    Keycloak: 'keycloak',
    Neutron: 'neutron',
    Nova: 'nova',
    Cyborg: 'cyborg',
    Ironic: 'ironic',
    Glance: 'glance',
    Cinder: 'cinder',
    Manila: 'manila',
    Swift: 'swift',
    Heat: 'heat',
    Octavia: 'octavia',
    Designate: 'designate',
    Rancher: 'rancher',
    Masakari: 'masakari',
    Zookeeper: 'zookeeper',
    Kafka: 'kafka',
    Monasca: 'monasca',
    Telegraf: 'telegraf',
    Grafana: 'grafana',
    Filebeat: 'filebeat',
    Auditbeat: 'auditbeat',
    Logstash: 'logstash',
    Opensearch: 'opensearch',
    OpensearchDashboards: 'opensearch-dashboards',
    Influxdb: 'influxdb',
    Kapacitor: 'kapacitor'
} as const;
export type RepairModuleHealthModuleTypeEnum = typeof RepairModuleHealthModuleTypeEnum[keyof typeof RepairModuleHealthModuleTypeEnum];


/**
 * IntegrationsApi - axios parameter creator
 * @export
 */
export const IntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the list of integrated applications
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrations: async (dataCenter: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getIntegrations', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/integrations`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of integrated applications
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrations(dataCenter: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIntegrationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegrations(dataCenter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getIntegrations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of integrated applications
         * @param {IntegrationsApiGetIntegrationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrations(requestParameters: IntegrationsApiGetIntegrationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetIntegrationsResponse> {
            return localVarFp.getIntegrations(requestParameters.dataCenter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getIntegrations operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetIntegrationsRequest
 */
export interface IntegrationsApiGetIntegrationsRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof IntegrationsApiGetIntegrations
     */
    readonly dataCenter: string
}

/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the list of integrated applications
     * @param {IntegrationsApiGetIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegrations(requestParameters: IntegrationsApiGetIntegrationsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getIntegrations(requestParameters.dataCenter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LicensesApi - axios parameter creator
 * @export
 */
export const LicensesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the list of licenses
         * @param {string} dataCenter The name of the data center to operate
         * @param {number} [pageNum] The page number of the event chunking to fetch (default is 1).
         * @param {number} [pageSize] The size per page of the events to return (default is unlimit).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenses: async (dataCenter: string, pageNum?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getLicenses', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/licenses`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update licenses for the cluster
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} node The name of the node to operate
         * @param {File} license License file (must have a .license extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importClusterLicense: async (dataCenter: string, node: string, license: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('importClusterLicense', 'dataCenter', dataCenter)
            // verify required parameter 'node' is not null or undefined
            assertParamExists('importClusterLicense', 'node', node)
            // verify required parameter 'license' is not null or undefined
            assertParamExists('importClusterLicense', 'license', license)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/licenses`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (license !== undefined) { 
                localVarFormParams.append('license', license as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update licenses for specific node
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} node The name of the node to operate
         * @param {File} license License file (must have a .license extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importNodeLicense: async (dataCenter: string, node: string, license: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('importNodeLicense', 'dataCenter', dataCenter)
            // verify required parameter 'node' is not null or undefined
            assertParamExists('importNodeLicense', 'node', node)
            // verify required parameter 'license' is not null or undefined
            assertParamExists('importNodeLicense', 'license', license)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/nodes/{node}/licenses`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (license !== undefined) { 
                localVarFormParams.append('license', license as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicensesApi - functional programming interface
 * @export
 */
export const LicensesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LicensesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of licenses
         * @param {string} dataCenter The name of the data center to operate
         * @param {number} [pageNum] The page number of the event chunking to fetch (default is 1).
         * @param {number} [pageSize] The size per page of the events to return (default is unlimit).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicenses(dataCenter: string, pageNum?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLicensesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenses(dataCenter, pageNum, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicensesApi.getLicenses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update licenses for the cluster
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} node The name of the node to operate
         * @param {File} license License file (must have a .license extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importClusterLicense(dataCenter: string, node: string, license: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostLicenseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importClusterLicense(dataCenter, node, license, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicensesApi.importClusterLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update licenses for specific node
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} node The name of the node to operate
         * @param {File} license License file (must have a .license extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importNodeLicense(dataCenter: string, node: string, license: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostLicenseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importNodeLicense(dataCenter, node, license, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicensesApi.importNodeLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LicensesApi - factory interface
 * @export
 */
export const LicensesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LicensesApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of licenses
         * @param {LicensesApiGetLicensesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenses(requestParameters: LicensesApiGetLicensesRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetLicensesResponse> {
            return localVarFp.getLicenses(requestParameters.dataCenter, requestParameters.pageNum, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update licenses for the cluster
         * @param {LicensesApiImportClusterLicenseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importClusterLicense(requestParameters: LicensesApiImportClusterLicenseRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostLicenseResponse> {
            return localVarFp.importClusterLicense(requestParameters.dataCenter, requestParameters.node, requestParameters.license, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update licenses for specific node
         * @param {LicensesApiImportNodeLicenseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importNodeLicense(requestParameters: LicensesApiImportNodeLicenseRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostLicenseResponse> {
            return localVarFp.importNodeLicense(requestParameters.dataCenter, requestParameters.node, requestParameters.license, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getLicenses operation in LicensesApi.
 * @export
 * @interface LicensesApiGetLicensesRequest
 */
export interface LicensesApiGetLicensesRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof LicensesApiGetLicenses
     */
    readonly dataCenter: string

    /**
     * The page number of the event chunking to fetch (default is 1).
     * @type {number}
     * @memberof LicensesApiGetLicenses
     */
    readonly pageNum?: number

    /**
     * The size per page of the events to return (default is unlimit).
     * @type {number}
     * @memberof LicensesApiGetLicenses
     */
    readonly pageSize?: number
}

/**
 * Request parameters for importClusterLicense operation in LicensesApi.
 * @export
 * @interface LicensesApiImportClusterLicenseRequest
 */
export interface LicensesApiImportClusterLicenseRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof LicensesApiImportClusterLicense
     */
    readonly dataCenter: string

    /**
     * The name of the node to operate
     * @type {string}
     * @memberof LicensesApiImportClusterLicense
     */
    readonly node: string

    /**
     * License file (must have a .license extension)
     * @type {File}
     * @memberof LicensesApiImportClusterLicense
     */
    readonly license: File
}

/**
 * Request parameters for importNodeLicense operation in LicensesApi.
 * @export
 * @interface LicensesApiImportNodeLicenseRequest
 */
export interface LicensesApiImportNodeLicenseRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof LicensesApiImportNodeLicense
     */
    readonly dataCenter: string

    /**
     * The name of the node to operate
     * @type {string}
     * @memberof LicensesApiImportNodeLicense
     */
    readonly node: string

    /**
     * License file (must have a .license extension)
     * @type {File}
     * @memberof LicensesApiImportNodeLicense
     */
    readonly license: File
}

/**
 * LicensesApi - object-oriented interface
 * @export
 * @class LicensesApi
 * @extends {BaseAPI}
 */
export class LicensesApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the list of licenses
     * @param {LicensesApiGetLicensesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensesApi
     */
    public getLicenses(requestParameters: LicensesApiGetLicensesRequest, options?: RawAxiosRequestConfig) {
        return LicensesApiFp(this.configuration).getLicenses(requestParameters.dataCenter, requestParameters.pageNum, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update licenses for the cluster
     * @param {LicensesApiImportClusterLicenseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensesApi
     */
    public importClusterLicense(requestParameters: LicensesApiImportClusterLicenseRequest, options?: RawAxiosRequestConfig) {
        return LicensesApiFp(this.configuration).importClusterLicense(requestParameters.dataCenter, requestParameters.node, requestParameters.license, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update licenses for specific node
     * @param {LicensesApiImportNodeLicenseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensesApi
     */
    public importNodeLicense(requestParameters: LicensesApiImportNodeLicenseRequest, options?: RawAxiosRequestConfig) {
        return LicensesApiFp(this.configuration).importNodeLicense(requestParameters.dataCenter, requestParameters.node, requestParameters.license, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LogoutApi - axios parameter creator
 * @export
 */
export const LogoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Logout from the system and redirect to login page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogoutApi - functional programming interface
 * @export
 */
export const LogoutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogoutApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Logout from the system and redirect to login page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogoutApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LogoutApi - factory interface
 * @export
 */
export const LogoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogoutApiFp(configuration)
    return {
        /**
         * 
         * @summary Logout from the system and redirect to login page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogoutApi - object-oriented interface
 * @export
 * @class LogoutApi
 * @extends {BaseAPI}
 */
export class LogoutApi extends BaseAPI {
    /**
     * 
     * @summary Logout from the system and redirect to login page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogoutApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return LogoutApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the various metrics with different view from hosts or vms
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetMetricByTypesMetricTypeEnum} metricType The type of metric to query, the value can be \&#39;cpuUsage\&#39;, \&#39;memoryUsage\&#39;, \&#39;diskUsage\&#39;, \&#39;diskBandwidth\&#39;, \&#39;diskIops\&#39;, \&#39;diskLatency\&#39;, \&#39;diskReadIops\&#39;, \&#39;diskWriteIops\&#39;, \&#39;networkTrafficIn\&#39;, or \&#39;networkTrafficOut\&#39;.
         * @param {GetMetricByTypesViewTypeEnum} viewType The type of view to query, the value can be only \&#39;summary\&#39;, \&#39;history\&#39;, or \&#39;rank\&#39;.
         * @param {GetMetricByTypesEntityTypeEnum} entityType The type of entity to query, the value can be \&#39;hosts\&#39; or \&#39;vms\&#39;
         * @param {string} [start] The start time of the event to query, the value should be in RFC3339 format (default is 24 hours ago).
         * @param {string} [stop] The end time of the event to query, the value should be in RFC3339 format (default is now).
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricByTypes: async (dataCenter: string, metricType: GetMetricByTypesMetricTypeEnum, viewType: GetMetricByTypesViewTypeEnum, entityType: GetMetricByTypesEntityTypeEnum, start?: string, stop?: string, watch?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getMetricByTypes', 'dataCenter', dataCenter)
            // verify required parameter 'metricType' is not null or undefined
            assertParamExists('getMetricByTypes', 'metricType', metricType)
            // verify required parameter 'viewType' is not null or undefined
            assertParamExists('getMetricByTypes', 'viewType', viewType)
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('getMetricByTypes', 'entityType', entityType)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/metrics/{metricType}/{viewType}/{entityType}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"metricType"}}`, encodeURIComponent(String(metricType)))
                .replace(`{${"viewType"}}`, encodeURIComponent(String(viewType)))
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (stop !== undefined) {
                localVarQueryParameter['stop'] = stop;
            }

            if (watch !== undefined) {
                localVarQueryParameter['watch'] = watch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the metrics of data center
         * @param {string} dataCenter The name of the data center to operate
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsOverview: async (dataCenter: string, watch?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getMetricsOverview', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/metrics`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (watch !== undefined) {
                localVarQueryParameter['watch'] = watch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the various metrics with different view from hosts or vms
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetMetricByTypesMetricTypeEnum} metricType The type of metric to query, the value can be \&#39;cpuUsage\&#39;, \&#39;memoryUsage\&#39;, \&#39;diskUsage\&#39;, \&#39;diskBandwidth\&#39;, \&#39;diskIops\&#39;, \&#39;diskLatency\&#39;, \&#39;diskReadIops\&#39;, \&#39;diskWriteIops\&#39;, \&#39;networkTrafficIn\&#39;, or \&#39;networkTrafficOut\&#39;.
         * @param {GetMetricByTypesViewTypeEnum} viewType The type of view to query, the value can be only \&#39;summary\&#39;, \&#39;history\&#39;, or \&#39;rank\&#39;.
         * @param {GetMetricByTypesEntityTypeEnum} entityType The type of entity to query, the value can be \&#39;hosts\&#39; or \&#39;vms\&#39;
         * @param {string} [start] The start time of the event to query, the value should be in RFC3339 format (default is 24 hours ago).
         * @param {string} [stop] The end time of the event to query, the value should be in RFC3339 format (default is now).
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricByTypes(dataCenter: string, metricType: GetMetricByTypesMetricTypeEnum, viewType: GetMetricByTypesViewTypeEnum, entityType: GetMetricByTypesEntityTypeEnum, start?: string, stop?: string, watch?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetricByTypes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricByTypes(dataCenter, metricType, viewType, entityType, start, stop, watch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.getMetricByTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the metrics of data center
         * @param {string} dataCenter The name of the data center to operate
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsOverview(dataCenter: string, watch?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricsOverview(dataCenter, watch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.getMetricsOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the various metrics with different view from hosts or vms
         * @param {MetricsApiGetMetricByTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricByTypes(requestParameters: MetricsApiGetMetricByTypesRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetMetricByTypes200Response> {
            return localVarFp.getMetricByTypes(requestParameters.dataCenter, requestParameters.metricType, requestParameters.viewType, requestParameters.entityType, requestParameters.start, requestParameters.stop, requestParameters.watch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the metrics of data center
         * @param {MetricsApiGetMetricsOverviewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsOverview(requestParameters: MetricsApiGetMetricsOverviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetMetricsResponse> {
            return localVarFp.getMetricsOverview(requestParameters.dataCenter, requestParameters.watch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMetricByTypes operation in MetricsApi.
 * @export
 * @interface MetricsApiGetMetricByTypesRequest
 */
export interface MetricsApiGetMetricByTypesRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof MetricsApiGetMetricByTypes
     */
    readonly dataCenter: string

    /**
     * The type of metric to query, the value can be \&#39;cpuUsage\&#39;, \&#39;memoryUsage\&#39;, \&#39;diskUsage\&#39;, \&#39;diskBandwidth\&#39;, \&#39;diskIops\&#39;, \&#39;diskLatency\&#39;, \&#39;diskReadIops\&#39;, \&#39;diskWriteIops\&#39;, \&#39;networkTrafficIn\&#39;, or \&#39;networkTrafficOut\&#39;.
     * @type {'cpuUsage' | 'memoryUsage' | 'diskUsage' | 'diskBandwidth' | 'diskIops' | 'diskLatency' | 'diskReadIops' | 'diskWriteIops' | 'networkTrafficIn' | 'networkTrafficOut'}
     * @memberof MetricsApiGetMetricByTypes
     */
    readonly metricType: GetMetricByTypesMetricTypeEnum

    /**
     * The type of view to query, the value can be only \&#39;summary\&#39;, \&#39;history\&#39;, or \&#39;rank\&#39;.
     * @type {'summary' | 'history' | 'rank'}
     * @memberof MetricsApiGetMetricByTypes
     */
    readonly viewType: GetMetricByTypesViewTypeEnum

    /**
     * The type of entity to query, the value can be \&#39;hosts\&#39; or \&#39;vms\&#39;
     * @type {'hosts' | 'vms'}
     * @memberof MetricsApiGetMetricByTypes
     */
    readonly entityType: GetMetricByTypesEntityTypeEnum

    /**
     * The start time of the event to query, the value should be in RFC3339 format (default is 24 hours ago).
     * @type {string}
     * @memberof MetricsApiGetMetricByTypes
     */
    readonly start?: string

    /**
     * The end time of the event to query, the value should be in RFC3339 format (default is now).
     * @type {string}
     * @memberof MetricsApiGetMetricByTypes
     */
    readonly stop?: string

    /**
     * The toggle to enable http chunked transfer for continuous server push.
     * @type {boolean}
     * @memberof MetricsApiGetMetricByTypes
     */
    readonly watch?: boolean
}

/**
 * Request parameters for getMetricsOverview operation in MetricsApi.
 * @export
 * @interface MetricsApiGetMetricsOverviewRequest
 */
export interface MetricsApiGetMetricsOverviewRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof MetricsApiGetMetricsOverview
     */
    readonly dataCenter: string

    /**
     * The toggle to enable http chunked transfer for continuous server push.
     * @type {boolean}
     * @memberof MetricsApiGetMetricsOverview
     */
    readonly watch?: boolean
}

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the various metrics with different view from hosts or vms
     * @param {MetricsApiGetMetricByTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetricByTypes(requestParameters: MetricsApiGetMetricByTypesRequest, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetricByTypes(requestParameters.dataCenter, requestParameters.metricType, requestParameters.viewType, requestParameters.entityType, requestParameters.start, requestParameters.stop, requestParameters.watch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the metrics of data center
     * @param {MetricsApiGetMetricsOverviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetricsOverview(requestParameters: MetricsApiGetMetricsOverviewRequest, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetricsOverview(requestParameters.dataCenter, requestParameters.watch, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetMetricByTypesMetricTypeEnum = {
    CpuUsage: 'cpuUsage',
    MemoryUsage: 'memoryUsage',
    DiskUsage: 'diskUsage',
    DiskBandwidth: 'diskBandwidth',
    DiskIops: 'diskIops',
    DiskLatency: 'diskLatency',
    DiskReadIops: 'diskReadIops',
    DiskWriteIops: 'diskWriteIops',
    NetworkTrafficIn: 'networkTrafficIn',
    NetworkTrafficOut: 'networkTrafficOut'
} as const;
export type GetMetricByTypesMetricTypeEnum = typeof GetMetricByTypesMetricTypeEnum[keyof typeof GetMetricByTypesMetricTypeEnum];
/**
 * @export
 */
export const GetMetricByTypesViewTypeEnum = {
    Summary: 'summary',
    History: 'history',
    Rank: 'rank'
} as const;
export type GetMetricByTypesViewTypeEnum = typeof GetMetricByTypesViewTypeEnum[keyof typeof GetMetricByTypesViewTypeEnum];
/**
 * @export
 */
export const GetMetricByTypesEntityTypeEnum = {
    Hosts: 'hosts',
    Vms: 'vms'
} as const;
export type GetMetricByTypesEntityTypeEnum = typeof GetMetricByTypesEntityTypeEnum[keyof typeof GetMetricByTypesEntityTypeEnum];


/**
 * NodesApi - axios parameter creator
 * @export
 */
export const NodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the list of nodes
         * @param {string} dataCenter The name of the data center to operate
         * @param {number} [pageNum] The page number of the event chunking to fetch (default is 1).
         * @param {number} [pageSize] The size per page of the events to return (default is unlimit).
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes: async (dataCenter: string, pageNum?: number, pageSize?: number, watch?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getNodes', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/nodes`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (watch !== undefined) {
                localVarQueryParameter['watch'] = watch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesApi - functional programming interface
 * @export
 */
export const NodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of nodes
         * @param {string} dataCenter The name of the data center to operate
         * @param {number} [pageNum] The page number of the event chunking to fetch (default is 1).
         * @param {number} [pageSize] The size per page of the events to return (default is unlimit).
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodes(dataCenter: string, pageNum?: number, pageSize?: number, watch?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNodesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodes(dataCenter, pageNum, pageSize, watch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodesApi.getNodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NodesApi - factory interface
 * @export
 */
export const NodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodesApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of nodes
         * @param {NodesApiGetNodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(requestParameters: NodesApiGetNodesRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetNodesResponse> {
            return localVarFp.getNodes(requestParameters.dataCenter, requestParameters.pageNum, requestParameters.pageSize, requestParameters.watch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getNodes operation in NodesApi.
 * @export
 * @interface NodesApiGetNodesRequest
 */
export interface NodesApiGetNodesRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof NodesApiGetNodes
     */
    readonly dataCenter: string

    /**
     * The page number of the event chunking to fetch (default is 1).
     * @type {number}
     * @memberof NodesApiGetNodes
     */
    readonly pageNum?: number

    /**
     * The size per page of the events to return (default is unlimit).
     * @type {number}
     * @memberof NodesApiGetNodes
     */
    readonly pageSize?: number

    /**
     * The toggle to enable http chunked transfer for continuous server push.
     * @type {boolean}
     * @memberof NodesApiGetNodes
     */
    readonly watch?: boolean
}

/**
 * NodesApi - object-oriented interface
 * @export
 * @class NodesApi
 * @extends {BaseAPI}
 */
export class NodesApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the list of nodes
     * @param {NodesApiGetNodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getNodes(requestParameters: NodesApiGetNodesRequest, options?: RawAxiosRequestConfig) {
        return NodesApiFp(this.configuration).getNodes(requestParameters.dataCenter, requestParameters.pageNum, requestParameters.pageSize, requestParameters.watch, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServicesApi - axios parameter creator
 * @export
 */
export const ServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the list of services
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServices: async (dataCenter: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getServices', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/services`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicesApi - functional programming interface
 * @export
 */
export const ServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of services
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServices(dataCenter: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetServicesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServices(dataCenter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicesApi.getServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServicesApi - factory interface
 * @export
 */
export const ServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of services
         * @param {ServicesApiGetServicesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServices(requestParameters: ServicesApiGetServicesRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetServicesResponse> {
            return localVarFp.getServices(requestParameters.dataCenter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getServices operation in ServicesApi.
 * @export
 * @interface ServicesApiGetServicesRequest
 */
export interface ServicesApiGetServicesRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof ServicesApiGetServices
     */
    readonly dataCenter: string
}

/**
 * ServicesApi - object-oriented interface
 * @export
 * @class ServicesApi
 * @extends {BaseAPI}
 */
export class ServicesApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the list of services
     * @param {ServicesApiGetServicesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public getServices(requestParameters: ServicesApiGetServicesRequest, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).getServices(requestParameters.dataCenter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an email recipient
         * @param {string} dataCenter The name of the data center to operate
         * @param {EmailRecipient} emailRecipient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailRecipient: async (dataCenter: string, emailRecipient: EmailRecipient, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('createEmailRecipient', 'dataCenter', dataCenter)
            // verify required parameter 'emailRecipient' is not null or undefined
            assertParamExists('createEmailRecipient', 'emailRecipient', emailRecipient)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/email/recipients`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailRecipient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an email sender
         * @param {string} dataCenter The name of the data center to operate
         * @param {EmailSender} emailSender 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailSender: async (dataCenter: string, emailSender: EmailSender, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('createEmailSender', 'dataCenter', dataCenter)
            // verify required parameter 'emailSender' is not null or undefined
            assertParamExists('createEmailSender', 'emailSender', emailSender)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/email/senders`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailSender, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a slack channel
         * @param {string} dataCenter The name of the data center to operate
         * @param {SlackChannel} slackChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSlackChannel: async (dataCenter: string, slackChannel: SlackChannel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('createSlackChannel', 'dataCenter', dataCenter)
            // verify required parameter 'slackChannel' is not null or undefined
            assertParamExists('createSlackChannel', 'slackChannel', slackChannel)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/slack/channels`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(slackChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an email recipient
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} recipientEmail recipient email to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailRecipient: async (dataCenter: string, recipientEmail: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('deleteEmailRecipient', 'dataCenter', dataCenter)
            // verify required parameter 'recipientEmail' is not null or undefined
            assertParamExists('deleteEmailRecipient', 'recipientEmail', recipientEmail)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/email/recipients/{recipientEmail}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"recipientEmail"}}`, encodeURIComponent(String(recipientEmail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an email sender
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} senderHost The host of the email sender to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSender: async (dataCenter: string, senderHost: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('deleteEmailSender', 'dataCenter', dataCenter)
            // verify required parameter 'senderHost' is not null or undefined
            assertParamExists('deleteEmailSender', 'senderHost', senderHost)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/email/senders/{senderHost}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"senderHost"}}`, encodeURIComponent(String(senderHost)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a slack channel
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} channelName channel name to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSlackChannel: async (dataCenter: string, channelName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('deleteSlackChannel', 'dataCenter', dataCenter)
            // verify required parameter 'channelName' is not null or undefined
            assertParamExists('deleteSlackChannel', 'channelName', channelName)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/slack/channels/{channelName}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"channelName"}}`, encodeURIComponent(String(channelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve email recipients
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailRecipients: async (dataCenter: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getEmailRecipients', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/email/recipients`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve email senders
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSenders: async (dataCenter: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getEmailSenders', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/email/senders`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve setting
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings: async (dataCenter: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getSettings', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve slack channels
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackChannels: async (dataCenter: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getSlackChannels', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/slack/channels`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Try an email recipient
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} recipientEmail recipient email to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tryEmailRecipient: async (dataCenter: string, recipientEmail: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('tryEmailRecipient', 'dataCenter', dataCenter)
            // verify required parameter 'recipientEmail' is not null or undefined
            assertParamExists('tryEmailRecipient', 'recipientEmail', recipientEmail)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/email/recipients/{recipientEmail}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"recipientEmail"}}`, encodeURIComponent(String(recipientEmail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Try an email sender
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} senderHost The host of the email sender to operate
         * @param {TryEmailSender} tryEmailSender 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tryEmailSender: async (dataCenter: string, senderHost: string, tryEmailSender: TryEmailSender, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('tryEmailSender', 'dataCenter', dataCenter)
            // verify required parameter 'senderHost' is not null or undefined
            assertParamExists('tryEmailSender', 'senderHost', senderHost)
            // verify required parameter 'tryEmailSender' is not null or undefined
            assertParamExists('tryEmailSender', 'tryEmailSender', tryEmailSender)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/email/senders/{senderHost}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"senderHost"}}`, encodeURIComponent(String(senderHost)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tryEmailSender, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Try a slack channel
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} channelName channel name to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trySlackChannel: async (dataCenter: string, channelName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('trySlackChannel', 'dataCenter', dataCenter)
            // verify required parameter 'channelName' is not null or undefined
            assertParamExists('trySlackChannel', 'channelName', channelName)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/slack/channels/{channelName}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"channelName"}}`, encodeURIComponent(String(channelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an email recipient
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} recipientEmail recipient email to update
         * @param {EmailRecipient} emailRecipient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailRecipient: async (dataCenter: string, recipientEmail: string, emailRecipient: EmailRecipient, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('updateEmailRecipient', 'dataCenter', dataCenter)
            // verify required parameter 'recipientEmail' is not null or undefined
            assertParamExists('updateEmailRecipient', 'recipientEmail', recipientEmail)
            // verify required parameter 'emailRecipient' is not null or undefined
            assertParamExists('updateEmailRecipient', 'emailRecipient', emailRecipient)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/email/recipients/{recipientEmail}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"recipientEmail"}}`, encodeURIComponent(String(recipientEmail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailRecipient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an email sender
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} senderHost The host of the email sender to operate
         * @param {EmailSender} emailSender 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailSender: async (dataCenter: string, senderHost: string, emailSender: EmailSender, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('updateEmailSender', 'dataCenter', dataCenter)
            // verify required parameter 'senderHost' is not null or undefined
            assertParamExists('updateEmailSender', 'senderHost', senderHost)
            // verify required parameter 'emailSender' is not null or undefined
            assertParamExists('updateEmailSender', 'emailSender', emailSender)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/email/senders/{senderHost}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"senderHost"}}`, encodeURIComponent(String(senderHost)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailSender, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a slack channel
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} channelName channel name to update
         * @param {SlackChannel} slackChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSlackChannel: async (dataCenter: string, channelName: string, slackChannel: SlackChannel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('updateSlackChannel', 'dataCenter', dataCenter)
            // verify required parameter 'channelName' is not null or undefined
            assertParamExists('updateSlackChannel', 'channelName', channelName)
            // verify required parameter 'slackChannel' is not null or undefined
            assertParamExists('updateSlackChannel', 'slackChannel', slackChannel)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/slack/channels/{channelName}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"channelName"}}`, encodeURIComponent(String(channelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(slackChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update title prefix
         * @param {string} dataCenter The name of the data center to operate
         * @param {TitlePrefix} titlePrefix 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTitlePrefix: async (dataCenter: string, titlePrefix: TitlePrefix, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('updateTitlePrefix', 'dataCenter', dataCenter)
            // verify required parameter 'titlePrefix' is not null or undefined
            assertParamExists('updateTitlePrefix', 'titlePrefix', titlePrefix)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/settings/titlePrefix`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(titlePrefix, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an email recipient
         * @param {string} dataCenter The name of the data center to operate
         * @param {EmailRecipient} emailRecipient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmailRecipient(dataCenter: string, emailRecipient: EmailRecipient, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostEmailRecipientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmailRecipient(dataCenter, emailRecipient, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.createEmailRecipient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an email sender
         * @param {string} dataCenter The name of the data center to operate
         * @param {EmailSender} emailSender 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmailSender(dataCenter: string, emailSender: EmailSender, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostEmailSenderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmailSender(dataCenter, emailSender, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.createEmailSender']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a slack channel
         * @param {string} dataCenter The name of the data center to operate
         * @param {SlackChannel} slackChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSlackChannel(dataCenter: string, slackChannel: SlackChannel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostSlackChannelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSlackChannel(dataCenter, slackChannel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.createSlackChannel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an email recipient
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} recipientEmail recipient email to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEmailRecipient(dataCenter: string, recipientEmail: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteEmailRecipientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEmailRecipient(dataCenter, recipientEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.deleteEmailRecipient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an email sender
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} senderHost The host of the email sender to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEmailSender(dataCenter: string, senderHost: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteEmailSenderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEmailSender(dataCenter, senderHost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.deleteEmailSender']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a slack channel
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} channelName channel name to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSlackChannel(dataCenter: string, channelName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteSlackChannelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSlackChannel(dataCenter, channelName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.deleteSlackChannel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve email recipients
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmailRecipients(dataCenter: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEmailRecipientsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmailRecipients(dataCenter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.getEmailRecipients']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve email senders
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmailSenders(dataCenter: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEmailSendersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmailSenders(dataCenter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.getEmailSenders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve setting
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettings(dataCenter: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSettingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettings(dataCenter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.getSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve slack channels
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlackChannels(dataCenter: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSlackChannelsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlackChannels(dataCenter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.getSlackChannels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Try an email recipient
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} recipientEmail recipient email to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tryEmailRecipient(dataCenter: string, recipientEmail: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TryEmailRecipientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tryEmailRecipient(dataCenter, recipientEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.tryEmailRecipient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Try an email sender
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} senderHost The host of the email sender to operate
         * @param {TryEmailSender} tryEmailSender 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tryEmailSender(dataCenter: string, senderHost: string, tryEmailSender: TryEmailSender, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TryEmailSenderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tryEmailSender(dataCenter, senderHost, tryEmailSender, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.tryEmailSender']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Try a slack channel
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} channelName channel name to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trySlackChannel(dataCenter: string, channelName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrySlackChannelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trySlackChannel(dataCenter, channelName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.trySlackChannel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an email recipient
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} recipientEmail recipient email to update
         * @param {EmailRecipient} emailRecipient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmailRecipient(dataCenter: string, recipientEmail: string, emailRecipient: EmailRecipient, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PutEmailRecipientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmailRecipient(dataCenter, recipientEmail, emailRecipient, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.updateEmailRecipient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an email sender
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} senderHost The host of the email sender to operate
         * @param {EmailSender} emailSender 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmailSender(dataCenter: string, senderHost: string, emailSender: EmailSender, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PutEmailSenderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmailSender(dataCenter, senderHost, emailSender, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.updateEmailSender']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a slack channel
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} channelName channel name to update
         * @param {SlackChannel} slackChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSlackChannel(dataCenter: string, channelName: string, slackChannel: SlackChannel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PutSlackChannelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSlackChannel(dataCenter, channelName, slackChannel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.updateSlackChannel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update title prefix
         * @param {string} dataCenter The name of the data center to operate
         * @param {TitlePrefix} titlePrefix 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTitlePrefix(dataCenter: string, titlePrefix: TitlePrefix, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateTitlePrefixResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTitlePrefix(dataCenter, titlePrefix, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.updateTitlePrefix']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an email recipient
         * @param {SettingsApiCreateEmailRecipientRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailRecipient(requestParameters: SettingsApiCreateEmailRecipientRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostEmailRecipientResponse> {
            return localVarFp.createEmailRecipient(requestParameters.dataCenter, requestParameters.emailRecipient, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an email sender
         * @param {SettingsApiCreateEmailSenderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailSender(requestParameters: SettingsApiCreateEmailSenderRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostEmailSenderResponse> {
            return localVarFp.createEmailSender(requestParameters.dataCenter, requestParameters.emailSender, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a slack channel
         * @param {SettingsApiCreateSlackChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSlackChannel(requestParameters: SettingsApiCreateSlackChannelRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostSlackChannelResponse> {
            return localVarFp.createSlackChannel(requestParameters.dataCenter, requestParameters.slackChannel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an email recipient
         * @param {SettingsApiDeleteEmailRecipientRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailRecipient(requestParameters: SettingsApiDeleteEmailRecipientRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteEmailRecipientResponse> {
            return localVarFp.deleteEmailRecipient(requestParameters.dataCenter, requestParameters.recipientEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an email sender
         * @param {SettingsApiDeleteEmailSenderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSender(requestParameters: SettingsApiDeleteEmailSenderRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteEmailSenderResponse> {
            return localVarFp.deleteEmailSender(requestParameters.dataCenter, requestParameters.senderHost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a slack channel
         * @param {SettingsApiDeleteSlackChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSlackChannel(requestParameters: SettingsApiDeleteSlackChannelRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteSlackChannelResponse> {
            return localVarFp.deleteSlackChannel(requestParameters.dataCenter, requestParameters.channelName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve email recipients
         * @param {SettingsApiGetEmailRecipientsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailRecipients(requestParameters: SettingsApiGetEmailRecipientsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetEmailRecipientsResponse> {
            return localVarFp.getEmailRecipients(requestParameters.dataCenter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve email senders
         * @param {SettingsApiGetEmailSendersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSenders(requestParameters: SettingsApiGetEmailSendersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetEmailSendersResponse> {
            return localVarFp.getEmailSenders(requestParameters.dataCenter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve setting
         * @param {SettingsApiGetSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(requestParameters: SettingsApiGetSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSettingResponse> {
            return localVarFp.getSettings(requestParameters.dataCenter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve slack channels
         * @param {SettingsApiGetSlackChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackChannels(requestParameters: SettingsApiGetSlackChannelsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSlackChannelsResponse> {
            return localVarFp.getSlackChannels(requestParameters.dataCenter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Try an email recipient
         * @param {SettingsApiTryEmailRecipientRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tryEmailRecipient(requestParameters: SettingsApiTryEmailRecipientRequest, options?: RawAxiosRequestConfig): AxiosPromise<TryEmailRecipientResponse> {
            return localVarFp.tryEmailRecipient(requestParameters.dataCenter, requestParameters.recipientEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Try an email sender
         * @param {SettingsApiTryEmailSenderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tryEmailSender(requestParameters: SettingsApiTryEmailSenderRequest, options?: RawAxiosRequestConfig): AxiosPromise<TryEmailSenderResponse> {
            return localVarFp.tryEmailSender(requestParameters.dataCenter, requestParameters.senderHost, requestParameters.tryEmailSender, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Try a slack channel
         * @param {SettingsApiTrySlackChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trySlackChannel(requestParameters: SettingsApiTrySlackChannelRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrySlackChannelResponse> {
            return localVarFp.trySlackChannel(requestParameters.dataCenter, requestParameters.channelName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an email recipient
         * @param {SettingsApiUpdateEmailRecipientRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailRecipient(requestParameters: SettingsApiUpdateEmailRecipientRequest, options?: RawAxiosRequestConfig): AxiosPromise<PutEmailRecipientResponse> {
            return localVarFp.updateEmailRecipient(requestParameters.dataCenter, requestParameters.recipientEmail, requestParameters.emailRecipient, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an email sender
         * @param {SettingsApiUpdateEmailSenderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailSender(requestParameters: SettingsApiUpdateEmailSenderRequest, options?: RawAxiosRequestConfig): AxiosPromise<PutEmailSenderResponse> {
            return localVarFp.updateEmailSender(requestParameters.dataCenter, requestParameters.senderHost, requestParameters.emailSender, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a slack channel
         * @param {SettingsApiUpdateSlackChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSlackChannel(requestParameters: SettingsApiUpdateSlackChannelRequest, options?: RawAxiosRequestConfig): AxiosPromise<PutSlackChannelResponse> {
            return localVarFp.updateSlackChannel(requestParameters.dataCenter, requestParameters.channelName, requestParameters.slackChannel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update title prefix
         * @param {SettingsApiUpdateTitlePrefixRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTitlePrefix(requestParameters: SettingsApiUpdateTitlePrefixRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateTitlePrefixResponse> {
            return localVarFp.updateTitlePrefix(requestParameters.dataCenter, requestParameters.titlePrefix, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createEmailRecipient operation in SettingsApi.
 * @export
 * @interface SettingsApiCreateEmailRecipientRequest
 */
export interface SettingsApiCreateEmailRecipientRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiCreateEmailRecipient
     */
    readonly dataCenter: string

    /**
     * 
     * @type {EmailRecipient}
     * @memberof SettingsApiCreateEmailRecipient
     */
    readonly emailRecipient: EmailRecipient
}

/**
 * Request parameters for createEmailSender operation in SettingsApi.
 * @export
 * @interface SettingsApiCreateEmailSenderRequest
 */
export interface SettingsApiCreateEmailSenderRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiCreateEmailSender
     */
    readonly dataCenter: string

    /**
     * 
     * @type {EmailSender}
     * @memberof SettingsApiCreateEmailSender
     */
    readonly emailSender: EmailSender
}

/**
 * Request parameters for createSlackChannel operation in SettingsApi.
 * @export
 * @interface SettingsApiCreateSlackChannelRequest
 */
export interface SettingsApiCreateSlackChannelRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiCreateSlackChannel
     */
    readonly dataCenter: string

    /**
     * 
     * @type {SlackChannel}
     * @memberof SettingsApiCreateSlackChannel
     */
    readonly slackChannel: SlackChannel
}

/**
 * Request parameters for deleteEmailRecipient operation in SettingsApi.
 * @export
 * @interface SettingsApiDeleteEmailRecipientRequest
 */
export interface SettingsApiDeleteEmailRecipientRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiDeleteEmailRecipient
     */
    readonly dataCenter: string

    /**
     * recipient email to delete
     * @type {string}
     * @memberof SettingsApiDeleteEmailRecipient
     */
    readonly recipientEmail: string
}

/**
 * Request parameters for deleteEmailSender operation in SettingsApi.
 * @export
 * @interface SettingsApiDeleteEmailSenderRequest
 */
export interface SettingsApiDeleteEmailSenderRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiDeleteEmailSender
     */
    readonly dataCenter: string

    /**
     * The host of the email sender to operate
     * @type {string}
     * @memberof SettingsApiDeleteEmailSender
     */
    readonly senderHost: string
}

/**
 * Request parameters for deleteSlackChannel operation in SettingsApi.
 * @export
 * @interface SettingsApiDeleteSlackChannelRequest
 */
export interface SettingsApiDeleteSlackChannelRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiDeleteSlackChannel
     */
    readonly dataCenter: string

    /**
     * channel name to delete
     * @type {string}
     * @memberof SettingsApiDeleteSlackChannel
     */
    readonly channelName: string
}

/**
 * Request parameters for getEmailRecipients operation in SettingsApi.
 * @export
 * @interface SettingsApiGetEmailRecipientsRequest
 */
export interface SettingsApiGetEmailRecipientsRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiGetEmailRecipients
     */
    readonly dataCenter: string
}

/**
 * Request parameters for getEmailSenders operation in SettingsApi.
 * @export
 * @interface SettingsApiGetEmailSendersRequest
 */
export interface SettingsApiGetEmailSendersRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiGetEmailSenders
     */
    readonly dataCenter: string
}

/**
 * Request parameters for getSettings operation in SettingsApi.
 * @export
 * @interface SettingsApiGetSettingsRequest
 */
export interface SettingsApiGetSettingsRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiGetSettings
     */
    readonly dataCenter: string
}

/**
 * Request parameters for getSlackChannels operation in SettingsApi.
 * @export
 * @interface SettingsApiGetSlackChannelsRequest
 */
export interface SettingsApiGetSlackChannelsRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiGetSlackChannels
     */
    readonly dataCenter: string
}

/**
 * Request parameters for tryEmailRecipient operation in SettingsApi.
 * @export
 * @interface SettingsApiTryEmailRecipientRequest
 */
export interface SettingsApiTryEmailRecipientRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiTryEmailRecipient
     */
    readonly dataCenter: string

    /**
     * recipient email to operate
     * @type {string}
     * @memberof SettingsApiTryEmailRecipient
     */
    readonly recipientEmail: string
}

/**
 * Request parameters for tryEmailSender operation in SettingsApi.
 * @export
 * @interface SettingsApiTryEmailSenderRequest
 */
export interface SettingsApiTryEmailSenderRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiTryEmailSender
     */
    readonly dataCenter: string

    /**
     * The host of the email sender to operate
     * @type {string}
     * @memberof SettingsApiTryEmailSender
     */
    readonly senderHost: string

    /**
     * 
     * @type {TryEmailSender}
     * @memberof SettingsApiTryEmailSender
     */
    readonly tryEmailSender: TryEmailSender
}

/**
 * Request parameters for trySlackChannel operation in SettingsApi.
 * @export
 * @interface SettingsApiTrySlackChannelRequest
 */
export interface SettingsApiTrySlackChannelRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiTrySlackChannel
     */
    readonly dataCenter: string

    /**
     * channel name to update
     * @type {string}
     * @memberof SettingsApiTrySlackChannel
     */
    readonly channelName: string
}

/**
 * Request parameters for updateEmailRecipient operation in SettingsApi.
 * @export
 * @interface SettingsApiUpdateEmailRecipientRequest
 */
export interface SettingsApiUpdateEmailRecipientRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiUpdateEmailRecipient
     */
    readonly dataCenter: string

    /**
     * recipient email to update
     * @type {string}
     * @memberof SettingsApiUpdateEmailRecipient
     */
    readonly recipientEmail: string

    /**
     * 
     * @type {EmailRecipient}
     * @memberof SettingsApiUpdateEmailRecipient
     */
    readonly emailRecipient: EmailRecipient
}

/**
 * Request parameters for updateEmailSender operation in SettingsApi.
 * @export
 * @interface SettingsApiUpdateEmailSenderRequest
 */
export interface SettingsApiUpdateEmailSenderRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiUpdateEmailSender
     */
    readonly dataCenter: string

    /**
     * The host of the email sender to operate
     * @type {string}
     * @memberof SettingsApiUpdateEmailSender
     */
    readonly senderHost: string

    /**
     * 
     * @type {EmailSender}
     * @memberof SettingsApiUpdateEmailSender
     */
    readonly emailSender: EmailSender
}

/**
 * Request parameters for updateSlackChannel operation in SettingsApi.
 * @export
 * @interface SettingsApiUpdateSlackChannelRequest
 */
export interface SettingsApiUpdateSlackChannelRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiUpdateSlackChannel
     */
    readonly dataCenter: string

    /**
     * channel name to update
     * @type {string}
     * @memberof SettingsApiUpdateSlackChannel
     */
    readonly channelName: string

    /**
     * 
     * @type {SlackChannel}
     * @memberof SettingsApiUpdateSlackChannel
     */
    readonly slackChannel: SlackChannel
}

/**
 * Request parameters for updateTitlePrefix operation in SettingsApi.
 * @export
 * @interface SettingsApiUpdateTitlePrefixRequest
 */
export interface SettingsApiUpdateTitlePrefixRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof SettingsApiUpdateTitlePrefix
     */
    readonly dataCenter: string

    /**
     * 
     * @type {TitlePrefix}
     * @memberof SettingsApiUpdateTitlePrefix
     */
    readonly titlePrefix: TitlePrefix
}

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * 
     * @summary Create an email recipient
     * @param {SettingsApiCreateEmailRecipientRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public createEmailRecipient(requestParameters: SettingsApiCreateEmailRecipientRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).createEmailRecipient(requestParameters.dataCenter, requestParameters.emailRecipient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an email sender
     * @param {SettingsApiCreateEmailSenderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public createEmailSender(requestParameters: SettingsApiCreateEmailSenderRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).createEmailSender(requestParameters.dataCenter, requestParameters.emailSender, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a slack channel
     * @param {SettingsApiCreateSlackChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public createSlackChannel(requestParameters: SettingsApiCreateSlackChannelRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).createSlackChannel(requestParameters.dataCenter, requestParameters.slackChannel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an email recipient
     * @param {SettingsApiDeleteEmailRecipientRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public deleteEmailRecipient(requestParameters: SettingsApiDeleteEmailRecipientRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).deleteEmailRecipient(requestParameters.dataCenter, requestParameters.recipientEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an email sender
     * @param {SettingsApiDeleteEmailSenderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public deleteEmailSender(requestParameters: SettingsApiDeleteEmailSenderRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).deleteEmailSender(requestParameters.dataCenter, requestParameters.senderHost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a slack channel
     * @param {SettingsApiDeleteSlackChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public deleteSlackChannel(requestParameters: SettingsApiDeleteSlackChannelRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).deleteSlackChannel(requestParameters.dataCenter, requestParameters.channelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve email recipients
     * @param {SettingsApiGetEmailRecipientsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getEmailRecipients(requestParameters: SettingsApiGetEmailRecipientsRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getEmailRecipients(requestParameters.dataCenter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve email senders
     * @param {SettingsApiGetEmailSendersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getEmailSenders(requestParameters: SettingsApiGetEmailSendersRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getEmailSenders(requestParameters.dataCenter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve setting
     * @param {SettingsApiGetSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getSettings(requestParameters: SettingsApiGetSettingsRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getSettings(requestParameters.dataCenter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve slack channels
     * @param {SettingsApiGetSlackChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getSlackChannels(requestParameters: SettingsApiGetSlackChannelsRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getSlackChannels(requestParameters.dataCenter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Try an email recipient
     * @param {SettingsApiTryEmailRecipientRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public tryEmailRecipient(requestParameters: SettingsApiTryEmailRecipientRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).tryEmailRecipient(requestParameters.dataCenter, requestParameters.recipientEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Try an email sender
     * @param {SettingsApiTryEmailSenderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public tryEmailSender(requestParameters: SettingsApiTryEmailSenderRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).tryEmailSender(requestParameters.dataCenter, requestParameters.senderHost, requestParameters.tryEmailSender, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Try a slack channel
     * @param {SettingsApiTrySlackChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public trySlackChannel(requestParameters: SettingsApiTrySlackChannelRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).trySlackChannel(requestParameters.dataCenter, requestParameters.channelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an email recipient
     * @param {SettingsApiUpdateEmailRecipientRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public updateEmailRecipient(requestParameters: SettingsApiUpdateEmailRecipientRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).updateEmailRecipient(requestParameters.dataCenter, requestParameters.recipientEmail, requestParameters.emailRecipient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an email sender
     * @param {SettingsApiUpdateEmailSenderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public updateEmailSender(requestParameters: SettingsApiUpdateEmailSenderRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).updateEmailSender(requestParameters.dataCenter, requestParameters.senderHost, requestParameters.emailSender, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a slack channel
     * @param {SettingsApiUpdateSlackChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public updateSlackChannel(requestParameters: SettingsApiUpdateSlackChannelRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).updateSlackChannel(requestParameters.dataCenter, requestParameters.channelName, requestParameters.slackChannel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update title prefix
     * @param {SettingsApiUpdateTitlePrefixRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public updateTitlePrefix(requestParameters: SettingsApiUpdateTitlePrefixRequest, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).updateTitlePrefix(requestParameters.dataCenter, requestParameters.titlePrefix, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the time-limited token for the data center
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetTokensRequest} getTokensRequest The user name and password to generate the token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (dataCenter: string, getTokensRequest: GetTokensRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getToken', 'dataCenter', dataCenter)
            // verify required parameter 'getTokensRequest' is not null or undefined
            assertParamExists('getToken', 'getTokensRequest', getTokensRequest)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/tokens`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getTokensRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the time-limited token for the data center
         * @param {string} dataCenter The name of the data center to operate
         * @param {GetTokensRequest} getTokensRequest The user name and password to generate the token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(dataCenter: string, getTokensRequest: GetTokensRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(dataCenter, getTokensRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokensApi.getToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokensApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the time-limited token for the data center
         * @param {TokensApiGetTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(requestParameters: TokensApiGetTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetTokensResponse> {
            return localVarFp.getToken(requestParameters.dataCenter, requestParameters.getTokensRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getToken operation in TokensApi.
 * @export
 * @interface TokensApiGetTokenRequest
 */
export interface TokensApiGetTokenRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof TokensApiGetToken
     */
    readonly dataCenter: string

    /**
     * The user name and password to generate the token
     * @type {GetTokensRequest}
     * @memberof TokensApiGetToken
     */
    readonly getTokensRequest: GetTokensRequest
}

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the time-limited token for the data center
     * @param {TokensApiGetTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public getToken(requestParameters: TokensApiGetTokenRequest, options?: RawAxiosRequestConfig) {
        return TokensApiFp(this.configuration).getToken(requestParameters.dataCenter, requestParameters.getTokensRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TuningsApi - axios parameter creator
 * @export
 */
export const TuningsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the list of tuning spec
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTuningSpecs: async (dataCenter: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('listTuningSpecs', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/tunings/specs`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the list of tunings from a host or data center
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} [host] The name of the host to retrieve the tunings, can specify multiple hosts to retrieve the tunings, for example: host&#x3D;example-node-0&amp;host&#x3D;example-node-1
         * @param {string} [keyword] The keyword to search the tunings
         * @param {number} [pageNum] The page number of the tunings list
         * @param {number} [pageSize] The page size of the tunings list
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTunings: async (dataCenter: string, host?: string, keyword?: string, pageNum?: number, pageSize?: number, watch?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('listTunings', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/tunings/parameters`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (pageNum !== undefined) {
                localVarQueryParameter['pageNum'] = pageNum;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (watch !== undefined) {
                localVarQueryParameter['watch'] = watch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset a specific tuning parameter
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} parameterName The name of the parameter to reset. use GET /api/v1/datacenters/{dataCenter}/tunings/specs to get the list of parameters
         * @param {ResetTuningRequest} resetTuningRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTuning: async (dataCenter: string, parameterName: string, resetTuningRequest: ResetTuningRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('resetTuning', 'dataCenter', dataCenter)
            // verify required parameter 'parameterName' is not null or undefined
            assertParamExists('resetTuning', 'parameterName', parameterName)
            // verify required parameter 'resetTuningRequest' is not null or undefined
            assertParamExists('resetTuning', 'resetTuningRequest', resetTuningRequest)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/tunings/parameters/{parameterName}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"parameterName"}}`, encodeURIComponent(String(parameterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetTuningRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update value for a specific tuning parameter
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} parameterName The name of the parameter to update. use GET /api/v1/datacenters/{dataCenter}/tunings/specs to get the list of parameters
         * @param {UpdateTuningRequest} updateTuningRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTuning: async (dataCenter: string, parameterName: string, updateTuningRequest: UpdateTuningRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('updateTuning', 'dataCenter', dataCenter)
            // verify required parameter 'parameterName' is not null or undefined
            assertParamExists('updateTuning', 'parameterName', parameterName)
            // verify required parameter 'updateTuningRequest' is not null or undefined
            assertParamExists('updateTuning', 'updateTuningRequest', updateTuningRequest)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/tunings/parameters/{parameterName}`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)))
                .replace(`{${"parameterName"}}`, encodeURIComponent(String(parameterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTuningRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TuningsApi - functional programming interface
 * @export
 */
export const TuningsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TuningsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of tuning spec
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTuningSpecs(dataCenter: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTuningSpecResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTuningSpecs(dataCenter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TuningsApi.listTuningSpecs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the list of tunings from a host or data center
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} [host] The name of the host to retrieve the tunings, can specify multiple hosts to retrieve the tunings, for example: host&#x3D;example-node-0&amp;host&#x3D;example-node-1
         * @param {string} [keyword] The keyword to search the tunings
         * @param {number} [pageNum] The page number of the tunings list
         * @param {number} [pageSize] The page size of the tunings list
         * @param {boolean} [watch] The toggle to enable http chunked transfer for continuous server push.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTunings(dataCenter: string, host?: string, keyword?: string, pageNum?: number, pageSize?: number, watch?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTuningResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTunings(dataCenter, host, keyword, pageNum, pageSize, watch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TuningsApi.listTunings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset a specific tuning parameter
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} parameterName The name of the parameter to reset. use GET /api/v1/datacenters/{dataCenter}/tunings/specs to get the list of parameters
         * @param {ResetTuningRequest} resetTuningRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetTuning(dataCenter: string, parameterName: string, resetTuningRequest: ResetTuningRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResetTuningResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetTuning(dataCenter, parameterName, resetTuningRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TuningsApi.resetTuning']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update value for a specific tuning parameter
         * @param {string} dataCenter The name of the data center to operate
         * @param {string} parameterName The name of the parameter to update. use GET /api/v1/datacenters/{dataCenter}/tunings/specs to get the list of parameters
         * @param {UpdateTuningRequest} updateTuningRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTuning(dataCenter: string, parameterName: string, updateTuningRequest: UpdateTuningRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateTuningResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTuning(dataCenter, parameterName, updateTuningRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TuningsApi.updateTuning']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TuningsApi - factory interface
 * @export
 */
export const TuningsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TuningsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of tuning spec
         * @param {TuningsApiListTuningSpecsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTuningSpecs(requestParameters: TuningsApiListTuningSpecsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListTuningSpecResponse> {
            return localVarFp.listTuningSpecs(requestParameters.dataCenter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the list of tunings from a host or data center
         * @param {TuningsApiListTuningsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTunings(requestParameters: TuningsApiListTuningsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListTuningResponse> {
            return localVarFp.listTunings(requestParameters.dataCenter, requestParameters.host, requestParameters.keyword, requestParameters.pageNum, requestParameters.pageSize, requestParameters.watch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset a specific tuning parameter
         * @param {TuningsApiResetTuningRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTuning(requestParameters: TuningsApiResetTuningRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResetTuningResponse> {
            return localVarFp.resetTuning(requestParameters.dataCenter, requestParameters.parameterName, requestParameters.resetTuningRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update value for a specific tuning parameter
         * @param {TuningsApiUpdateTuningRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTuning(requestParameters: TuningsApiUpdateTuningRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateTuningResponse> {
            return localVarFp.updateTuning(requestParameters.dataCenter, requestParameters.parameterName, requestParameters.updateTuningRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listTuningSpecs operation in TuningsApi.
 * @export
 * @interface TuningsApiListTuningSpecsRequest
 */
export interface TuningsApiListTuningSpecsRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof TuningsApiListTuningSpecs
     */
    readonly dataCenter: string
}

/**
 * Request parameters for listTunings operation in TuningsApi.
 * @export
 * @interface TuningsApiListTuningsRequest
 */
export interface TuningsApiListTuningsRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof TuningsApiListTunings
     */
    readonly dataCenter: string

    /**
     * The name of the host to retrieve the tunings, can specify multiple hosts to retrieve the tunings, for example: host&#x3D;example-node-0&amp;host&#x3D;example-node-1
     * @type {string}
     * @memberof TuningsApiListTunings
     */
    readonly host?: string

    /**
     * The keyword to search the tunings
     * @type {string}
     * @memberof TuningsApiListTunings
     */
    readonly keyword?: string

    /**
     * The page number of the tunings list
     * @type {number}
     * @memberof TuningsApiListTunings
     */
    readonly pageNum?: number

    /**
     * The page size of the tunings list
     * @type {number}
     * @memberof TuningsApiListTunings
     */
    readonly pageSize?: number

    /**
     * The toggle to enable http chunked transfer for continuous server push.
     * @type {boolean}
     * @memberof TuningsApiListTunings
     */
    readonly watch?: boolean
}

/**
 * Request parameters for resetTuning operation in TuningsApi.
 * @export
 * @interface TuningsApiResetTuningRequest
 */
export interface TuningsApiResetTuningRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof TuningsApiResetTuning
     */
    readonly dataCenter: string

    /**
     * The name of the parameter to reset. use GET /api/v1/datacenters/{dataCenter}/tunings/specs to get the list of parameters
     * @type {string}
     * @memberof TuningsApiResetTuning
     */
    readonly parameterName: string

    /**
     * 
     * @type {ResetTuningRequest}
     * @memberof TuningsApiResetTuning
     */
    readonly resetTuningRequest: ResetTuningRequest
}

/**
 * Request parameters for updateTuning operation in TuningsApi.
 * @export
 * @interface TuningsApiUpdateTuningRequest
 */
export interface TuningsApiUpdateTuningRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof TuningsApiUpdateTuning
     */
    readonly dataCenter: string

    /**
     * The name of the parameter to update. use GET /api/v1/datacenters/{dataCenter}/tunings/specs to get the list of parameters
     * @type {string}
     * @memberof TuningsApiUpdateTuning
     */
    readonly parameterName: string

    /**
     * 
     * @type {UpdateTuningRequest}
     * @memberof TuningsApiUpdateTuning
     */
    readonly updateTuningRequest: UpdateTuningRequest
}

/**
 * TuningsApi - object-oriented interface
 * @export
 * @class TuningsApi
 * @extends {BaseAPI}
 */
export class TuningsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the list of tuning spec
     * @param {TuningsApiListTuningSpecsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TuningsApi
     */
    public listTuningSpecs(requestParameters: TuningsApiListTuningSpecsRequest, options?: RawAxiosRequestConfig) {
        return TuningsApiFp(this.configuration).listTuningSpecs(requestParameters.dataCenter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the list of tunings from a host or data center
     * @param {TuningsApiListTuningsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TuningsApi
     */
    public listTunings(requestParameters: TuningsApiListTuningsRequest, options?: RawAxiosRequestConfig) {
        return TuningsApiFp(this.configuration).listTunings(requestParameters.dataCenter, requestParameters.host, requestParameters.keyword, requestParameters.pageNum, requestParameters.pageSize, requestParameters.watch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset a specific tuning parameter
     * @param {TuningsApiResetTuningRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TuningsApi
     */
    public resetTuning(requestParameters: TuningsApiResetTuningRequest, options?: RawAxiosRequestConfig) {
        return TuningsApiFp(this.configuration).resetTuning(requestParameters.dataCenter, requestParameters.parameterName, requestParameters.resetTuningRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update value for a specific tuning parameter
     * @param {TuningsApiUpdateTuningRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TuningsApi
     */
    public updateTuning(requestParameters: TuningsApiUpdateTuningRequest, options?: RawAxiosRequestConfig) {
        return TuningsApiFp(this.configuration).updateTuning(requestParameters.dataCenter, requestParameters.parameterName, requestParameters.updateTuningRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserInfoApi - axios parameter creator
 * @export
 */
export const UserInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the own user info
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (dataCenter: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCenter' is not null or undefined
            assertParamExists('getMe', 'dataCenter', dataCenter)
            const localVarPath = `/api/v1/datacenters/{dataCenter}/me`
                .replace(`{${"dataCenter"}}`, encodeURIComponent(String(dataCenter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserInfoApi - functional programming interface
 * @export
 */
export const UserInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the own user info
         * @param {string} dataCenter The name of the data center to operate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(dataCenter: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(dataCenter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserInfoApi.getMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserInfoApi - factory interface
 * @export
 */
export const UserInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the own user info
         * @param {UserInfoApiGetMeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(requestParameters: UserInfoApiGetMeRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetMeResponse> {
            return localVarFp.getMe(requestParameters.dataCenter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMe operation in UserInfoApi.
 * @export
 * @interface UserInfoApiGetMeRequest
 */
export interface UserInfoApiGetMeRequest {
    /**
     * The name of the data center to operate
     * @type {string}
     * @memberof UserInfoApiGetMe
     */
    readonly dataCenter: string
}

/**
 * UserInfoApi - object-oriented interface
 * @export
 * @class UserInfoApi
 * @extends {BaseAPI}
 */
export class UserInfoApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the own user info
     * @param {UserInfoApiGetMeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserInfoApi
     */
    public getMe(requestParameters: UserInfoApiGetMeRequest, options?: RawAxiosRequestConfig) {
        return UserInfoApiFp(this.configuration).getMe(requestParameters.dataCenter, options).then((request) => request(this.axios, this.basePath));
    }
}



